// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/mindhit/api/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/mindhit/api/ent/highlight"
	"github.com/mindhit/api/ent/mindmapgraph"
	"github.com/mindhit/api/ent/pagevisit"
	"github.com/mindhit/api/ent/passwordresettoken"
	"github.com/mindhit/api/ent/plan"
	"github.com/mindhit/api/ent/rawevent"
	"github.com/mindhit/api/ent/session"
	"github.com/mindhit/api/ent/subscription"
	"github.com/mindhit/api/ent/tokenusage"
	"github.com/mindhit/api/ent/url"
	"github.com/mindhit/api/ent/user"
	"github.com/mindhit/api/ent/usersettings"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Highlight is the client for interacting with the Highlight builders.
	Highlight *HighlightClient
	// MindmapGraph is the client for interacting with the MindmapGraph builders.
	MindmapGraph *MindmapGraphClient
	// PageVisit is the client for interacting with the PageVisit builders.
	PageVisit *PageVisitClient
	// PasswordResetToken is the client for interacting with the PasswordResetToken builders.
	PasswordResetToken *PasswordResetTokenClient
	// Plan is the client for interacting with the Plan builders.
	Plan *PlanClient
	// RawEvent is the client for interacting with the RawEvent builders.
	RawEvent *RawEventClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// Subscription is the client for interacting with the Subscription builders.
	Subscription *SubscriptionClient
	// TokenUsage is the client for interacting with the TokenUsage builders.
	TokenUsage *TokenUsageClient
	// URL is the client for interacting with the URL builders.
	URL *URLClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserSettings is the client for interacting with the UserSettings builders.
	UserSettings *UserSettingsClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Highlight = NewHighlightClient(c.config)
	c.MindmapGraph = NewMindmapGraphClient(c.config)
	c.PageVisit = NewPageVisitClient(c.config)
	c.PasswordResetToken = NewPasswordResetTokenClient(c.config)
	c.Plan = NewPlanClient(c.config)
	c.RawEvent = NewRawEventClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.Subscription = NewSubscriptionClient(c.config)
	c.TokenUsage = NewTokenUsageClient(c.config)
	c.URL = NewURLClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserSettings = NewUserSettingsClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Highlight:          NewHighlightClient(cfg),
		MindmapGraph:       NewMindmapGraphClient(cfg),
		PageVisit:          NewPageVisitClient(cfg),
		PasswordResetToken: NewPasswordResetTokenClient(cfg),
		Plan:               NewPlanClient(cfg),
		RawEvent:           NewRawEventClient(cfg),
		Session:            NewSessionClient(cfg),
		Subscription:       NewSubscriptionClient(cfg),
		TokenUsage:         NewTokenUsageClient(cfg),
		URL:                NewURLClient(cfg),
		User:               NewUserClient(cfg),
		UserSettings:       NewUserSettingsClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Highlight:          NewHighlightClient(cfg),
		MindmapGraph:       NewMindmapGraphClient(cfg),
		PageVisit:          NewPageVisitClient(cfg),
		PasswordResetToken: NewPasswordResetTokenClient(cfg),
		Plan:               NewPlanClient(cfg),
		RawEvent:           NewRawEventClient(cfg),
		Session:            NewSessionClient(cfg),
		Subscription:       NewSubscriptionClient(cfg),
		TokenUsage:         NewTokenUsageClient(cfg),
		URL:                NewURLClient(cfg),
		User:               NewUserClient(cfg),
		UserSettings:       NewUserSettingsClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Highlight.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Highlight, c.MindmapGraph, c.PageVisit, c.PasswordResetToken, c.Plan,
		c.RawEvent, c.Session, c.Subscription, c.TokenUsage, c.URL, c.User,
		c.UserSettings,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Highlight, c.MindmapGraph, c.PageVisit, c.PasswordResetToken, c.Plan,
		c.RawEvent, c.Session, c.Subscription, c.TokenUsage, c.URL, c.User,
		c.UserSettings,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *HighlightMutation:
		return c.Highlight.mutate(ctx, m)
	case *MindmapGraphMutation:
		return c.MindmapGraph.mutate(ctx, m)
	case *PageVisitMutation:
		return c.PageVisit.mutate(ctx, m)
	case *PasswordResetTokenMutation:
		return c.PasswordResetToken.mutate(ctx, m)
	case *PlanMutation:
		return c.Plan.mutate(ctx, m)
	case *RawEventMutation:
		return c.RawEvent.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *SubscriptionMutation:
		return c.Subscription.mutate(ctx, m)
	case *TokenUsageMutation:
		return c.TokenUsage.mutate(ctx, m)
	case *URLMutation:
		return c.URL.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserSettingsMutation:
		return c.UserSettings.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// HighlightClient is a client for the Highlight schema.
type HighlightClient struct {
	config
}

// NewHighlightClient returns a client for the Highlight from the given config.
func NewHighlightClient(c config) *HighlightClient {
	return &HighlightClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `highlight.Hooks(f(g(h())))`.
func (c *HighlightClient) Use(hooks ...Hook) {
	c.hooks.Highlight = append(c.hooks.Highlight, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `highlight.Intercept(f(g(h())))`.
func (c *HighlightClient) Intercept(interceptors ...Interceptor) {
	c.inters.Highlight = append(c.inters.Highlight, interceptors...)
}

// Create returns a builder for creating a Highlight entity.
func (c *HighlightClient) Create() *HighlightCreate {
	mutation := newHighlightMutation(c.config, OpCreate)
	return &HighlightCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Highlight entities.
func (c *HighlightClient) CreateBulk(builders ...*HighlightCreate) *HighlightCreateBulk {
	return &HighlightCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HighlightClient) MapCreateBulk(slice any, setFunc func(*HighlightCreate, int)) *HighlightCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HighlightCreateBulk{err: fmt.Errorf("calling to HighlightClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HighlightCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HighlightCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Highlight.
func (c *HighlightClient) Update() *HighlightUpdate {
	mutation := newHighlightMutation(c.config, OpUpdate)
	return &HighlightUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HighlightClient) UpdateOne(_m *Highlight) *HighlightUpdateOne {
	mutation := newHighlightMutation(c.config, OpUpdateOne, withHighlight(_m))
	return &HighlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HighlightClient) UpdateOneID(id uuid.UUID) *HighlightUpdateOne {
	mutation := newHighlightMutation(c.config, OpUpdateOne, withHighlightID(id))
	return &HighlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Highlight.
func (c *HighlightClient) Delete() *HighlightDelete {
	mutation := newHighlightMutation(c.config, OpDelete)
	return &HighlightDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HighlightClient) DeleteOne(_m *Highlight) *HighlightDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HighlightClient) DeleteOneID(id uuid.UUID) *HighlightDeleteOne {
	builder := c.Delete().Where(highlight.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HighlightDeleteOne{builder}
}

// Query returns a query builder for Highlight.
func (c *HighlightClient) Query() *HighlightQuery {
	return &HighlightQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHighlight},
		inters: c.Interceptors(),
	}
}

// Get returns a Highlight entity by its id.
func (c *HighlightClient) Get(ctx context.Context, id uuid.UUID) (*Highlight, error) {
	return c.Query().Where(highlight.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HighlightClient) GetX(ctx context.Context, id uuid.UUID) *Highlight {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a Highlight.
func (c *HighlightClient) QuerySession(_m *Highlight) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(highlight.Table, highlight.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, highlight.SessionTable, highlight.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPageVisit queries the page_visit edge of a Highlight.
func (c *HighlightClient) QueryPageVisit(_m *Highlight) *PageVisitQuery {
	query := (&PageVisitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(highlight.Table, highlight.FieldID, id),
			sqlgraph.To(pagevisit.Table, pagevisit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, highlight.PageVisitTable, highlight.PageVisitColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HighlightClient) Hooks() []Hook {
	return c.hooks.Highlight
}

// Interceptors returns the client interceptors.
func (c *HighlightClient) Interceptors() []Interceptor {
	return c.inters.Highlight
}

func (c *HighlightClient) mutate(ctx context.Context, m *HighlightMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HighlightCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HighlightUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HighlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HighlightDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Highlight mutation op: %q", m.Op())
	}
}

// MindmapGraphClient is a client for the MindmapGraph schema.
type MindmapGraphClient struct {
	config
}

// NewMindmapGraphClient returns a client for the MindmapGraph from the given config.
func NewMindmapGraphClient(c config) *MindmapGraphClient {
	return &MindmapGraphClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mindmapgraph.Hooks(f(g(h())))`.
func (c *MindmapGraphClient) Use(hooks ...Hook) {
	c.hooks.MindmapGraph = append(c.hooks.MindmapGraph, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mindmapgraph.Intercept(f(g(h())))`.
func (c *MindmapGraphClient) Intercept(interceptors ...Interceptor) {
	c.inters.MindmapGraph = append(c.inters.MindmapGraph, interceptors...)
}

// Create returns a builder for creating a MindmapGraph entity.
func (c *MindmapGraphClient) Create() *MindmapGraphCreate {
	mutation := newMindmapGraphMutation(c.config, OpCreate)
	return &MindmapGraphCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MindmapGraph entities.
func (c *MindmapGraphClient) CreateBulk(builders ...*MindmapGraphCreate) *MindmapGraphCreateBulk {
	return &MindmapGraphCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MindmapGraphClient) MapCreateBulk(slice any, setFunc func(*MindmapGraphCreate, int)) *MindmapGraphCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MindmapGraphCreateBulk{err: fmt.Errorf("calling to MindmapGraphClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MindmapGraphCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MindmapGraphCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MindmapGraph.
func (c *MindmapGraphClient) Update() *MindmapGraphUpdate {
	mutation := newMindmapGraphMutation(c.config, OpUpdate)
	return &MindmapGraphUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MindmapGraphClient) UpdateOne(_m *MindmapGraph) *MindmapGraphUpdateOne {
	mutation := newMindmapGraphMutation(c.config, OpUpdateOne, withMindmapGraph(_m))
	return &MindmapGraphUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MindmapGraphClient) UpdateOneID(id uuid.UUID) *MindmapGraphUpdateOne {
	mutation := newMindmapGraphMutation(c.config, OpUpdateOne, withMindmapGraphID(id))
	return &MindmapGraphUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MindmapGraph.
func (c *MindmapGraphClient) Delete() *MindmapGraphDelete {
	mutation := newMindmapGraphMutation(c.config, OpDelete)
	return &MindmapGraphDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MindmapGraphClient) DeleteOne(_m *MindmapGraph) *MindmapGraphDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MindmapGraphClient) DeleteOneID(id uuid.UUID) *MindmapGraphDeleteOne {
	builder := c.Delete().Where(mindmapgraph.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MindmapGraphDeleteOne{builder}
}

// Query returns a query builder for MindmapGraph.
func (c *MindmapGraphClient) Query() *MindmapGraphQuery {
	return &MindmapGraphQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMindmapGraph},
		inters: c.Interceptors(),
	}
}

// Get returns a MindmapGraph entity by its id.
func (c *MindmapGraphClient) Get(ctx context.Context, id uuid.UUID) (*MindmapGraph, error) {
	return c.Query().Where(mindmapgraph.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MindmapGraphClient) GetX(ctx context.Context, id uuid.UUID) *MindmapGraph {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a MindmapGraph.
func (c *MindmapGraphClient) QuerySession(_m *MindmapGraph) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mindmapgraph.Table, mindmapgraph.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mindmapgraph.SessionTable, mindmapgraph.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MindmapGraphClient) Hooks() []Hook {
	return c.hooks.MindmapGraph
}

// Interceptors returns the client interceptors.
func (c *MindmapGraphClient) Interceptors() []Interceptor {
	return c.inters.MindmapGraph
}

func (c *MindmapGraphClient) mutate(ctx context.Context, m *MindmapGraphMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MindmapGraphCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MindmapGraphUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MindmapGraphUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MindmapGraphDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MindmapGraph mutation op: %q", m.Op())
	}
}

// PageVisitClient is a client for the PageVisit schema.
type PageVisitClient struct {
	config
}

// NewPageVisitClient returns a client for the PageVisit from the given config.
func NewPageVisitClient(c config) *PageVisitClient {
	return &PageVisitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pagevisit.Hooks(f(g(h())))`.
func (c *PageVisitClient) Use(hooks ...Hook) {
	c.hooks.PageVisit = append(c.hooks.PageVisit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pagevisit.Intercept(f(g(h())))`.
func (c *PageVisitClient) Intercept(interceptors ...Interceptor) {
	c.inters.PageVisit = append(c.inters.PageVisit, interceptors...)
}

// Create returns a builder for creating a PageVisit entity.
func (c *PageVisitClient) Create() *PageVisitCreate {
	mutation := newPageVisitMutation(c.config, OpCreate)
	return &PageVisitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PageVisit entities.
func (c *PageVisitClient) CreateBulk(builders ...*PageVisitCreate) *PageVisitCreateBulk {
	return &PageVisitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PageVisitClient) MapCreateBulk(slice any, setFunc func(*PageVisitCreate, int)) *PageVisitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PageVisitCreateBulk{err: fmt.Errorf("calling to PageVisitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PageVisitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PageVisitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PageVisit.
func (c *PageVisitClient) Update() *PageVisitUpdate {
	mutation := newPageVisitMutation(c.config, OpUpdate)
	return &PageVisitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PageVisitClient) UpdateOne(_m *PageVisit) *PageVisitUpdateOne {
	mutation := newPageVisitMutation(c.config, OpUpdateOne, withPageVisit(_m))
	return &PageVisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PageVisitClient) UpdateOneID(id uuid.UUID) *PageVisitUpdateOne {
	mutation := newPageVisitMutation(c.config, OpUpdateOne, withPageVisitID(id))
	return &PageVisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PageVisit.
func (c *PageVisitClient) Delete() *PageVisitDelete {
	mutation := newPageVisitMutation(c.config, OpDelete)
	return &PageVisitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PageVisitClient) DeleteOne(_m *PageVisit) *PageVisitDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PageVisitClient) DeleteOneID(id uuid.UUID) *PageVisitDeleteOne {
	builder := c.Delete().Where(pagevisit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PageVisitDeleteOne{builder}
}

// Query returns a query builder for PageVisit.
func (c *PageVisitClient) Query() *PageVisitQuery {
	return &PageVisitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePageVisit},
		inters: c.Interceptors(),
	}
}

// Get returns a PageVisit entity by its id.
func (c *PageVisitClient) Get(ctx context.Context, id uuid.UUID) (*PageVisit, error) {
	return c.Query().Where(pagevisit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PageVisitClient) GetX(ctx context.Context, id uuid.UUID) *PageVisit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a PageVisit.
func (c *PageVisitClient) QuerySession(_m *PageVisit) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pagevisit.Table, pagevisit.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pagevisit.SessionTable, pagevisit.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryURL queries the url edge of a PageVisit.
func (c *PageVisitClient) QueryURL(_m *PageVisit) *URLQuery {
	query := (&URLClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pagevisit.Table, pagevisit.FieldID, id),
			sqlgraph.To(url.Table, url.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pagevisit.URLTable, pagevisit.URLColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PageVisitClient) Hooks() []Hook {
	return c.hooks.PageVisit
}

// Interceptors returns the client interceptors.
func (c *PageVisitClient) Interceptors() []Interceptor {
	return c.inters.PageVisit
}

func (c *PageVisitClient) mutate(ctx context.Context, m *PageVisitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PageVisitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PageVisitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PageVisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PageVisitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PageVisit mutation op: %q", m.Op())
	}
}

// PasswordResetTokenClient is a client for the PasswordResetToken schema.
type PasswordResetTokenClient struct {
	config
}

// NewPasswordResetTokenClient returns a client for the PasswordResetToken from the given config.
func NewPasswordResetTokenClient(c config) *PasswordResetTokenClient {
	return &PasswordResetTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `passwordresettoken.Hooks(f(g(h())))`.
func (c *PasswordResetTokenClient) Use(hooks ...Hook) {
	c.hooks.PasswordResetToken = append(c.hooks.PasswordResetToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `passwordresettoken.Intercept(f(g(h())))`.
func (c *PasswordResetTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.PasswordResetToken = append(c.inters.PasswordResetToken, interceptors...)
}

// Create returns a builder for creating a PasswordResetToken entity.
func (c *PasswordResetTokenClient) Create() *PasswordResetTokenCreate {
	mutation := newPasswordResetTokenMutation(c.config, OpCreate)
	return &PasswordResetTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PasswordResetToken entities.
func (c *PasswordResetTokenClient) CreateBulk(builders ...*PasswordResetTokenCreate) *PasswordResetTokenCreateBulk {
	return &PasswordResetTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PasswordResetTokenClient) MapCreateBulk(slice any, setFunc func(*PasswordResetTokenCreate, int)) *PasswordResetTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PasswordResetTokenCreateBulk{err: fmt.Errorf("calling to PasswordResetTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PasswordResetTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PasswordResetTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Update() *PasswordResetTokenUpdate {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdate)
	return &PasswordResetTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PasswordResetTokenClient) UpdateOne(_m *PasswordResetToken) *PasswordResetTokenUpdateOne {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdateOne, withPasswordResetToken(_m))
	return &PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PasswordResetTokenClient) UpdateOneID(id uuid.UUID) *PasswordResetTokenUpdateOne {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdateOne, withPasswordResetTokenID(id))
	return &PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Delete() *PasswordResetTokenDelete {
	mutation := newPasswordResetTokenMutation(c.config, OpDelete)
	return &PasswordResetTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PasswordResetTokenClient) DeleteOne(_m *PasswordResetToken) *PasswordResetTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PasswordResetTokenClient) DeleteOneID(id uuid.UUID) *PasswordResetTokenDeleteOne {
	builder := c.Delete().Where(passwordresettoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PasswordResetTokenDeleteOne{builder}
}

// Query returns a query builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Query() *PasswordResetTokenQuery {
	return &PasswordResetTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePasswordResetToken},
		inters: c.Interceptors(),
	}
}

// Get returns a PasswordResetToken entity by its id.
func (c *PasswordResetTokenClient) Get(ctx context.Context, id uuid.UUID) (*PasswordResetToken, error) {
	return c.Query().Where(passwordresettoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PasswordResetTokenClient) GetX(ctx context.Context, id uuid.UUID) *PasswordResetToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a PasswordResetToken.
func (c *PasswordResetTokenClient) QueryUser(_m *PasswordResetToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(passwordresettoken.Table, passwordresettoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, passwordresettoken.UserTable, passwordresettoken.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PasswordResetTokenClient) Hooks() []Hook {
	return c.hooks.PasswordResetToken
}

// Interceptors returns the client interceptors.
func (c *PasswordResetTokenClient) Interceptors() []Interceptor {
	return c.inters.PasswordResetToken
}

func (c *PasswordResetTokenClient) mutate(ctx context.Context, m *PasswordResetTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PasswordResetTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PasswordResetTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PasswordResetTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PasswordResetToken mutation op: %q", m.Op())
	}
}

// PlanClient is a client for the Plan schema.
type PlanClient struct {
	config
}

// NewPlanClient returns a client for the Plan from the given config.
func NewPlanClient(c config) *PlanClient {
	return &PlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plan.Hooks(f(g(h())))`.
func (c *PlanClient) Use(hooks ...Hook) {
	c.hooks.Plan = append(c.hooks.Plan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plan.Intercept(f(g(h())))`.
func (c *PlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plan = append(c.inters.Plan, interceptors...)
}

// Create returns a builder for creating a Plan entity.
func (c *PlanClient) Create() *PlanCreate {
	mutation := newPlanMutation(c.config, OpCreate)
	return &PlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plan entities.
func (c *PlanClient) CreateBulk(builders ...*PlanCreate) *PlanCreateBulk {
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlanClient) MapCreateBulk(slice any, setFunc func(*PlanCreate, int)) *PlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlanCreateBulk{err: fmt.Errorf("calling to PlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plan.
func (c *PlanClient) Update() *PlanUpdate {
	mutation := newPlanMutation(c.config, OpUpdate)
	return &PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlanClient) UpdateOne(_m *Plan) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlan(_m))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlanClient) UpdateOneID(id string) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlanID(id))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plan.
func (c *PlanClient) Delete() *PlanDelete {
	mutation := newPlanMutation(c.config, OpDelete)
	return &PlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlanClient) DeleteOne(_m *Plan) *PlanDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlanClient) DeleteOneID(id string) *PlanDeleteOne {
	builder := c.Delete().Where(plan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlanDeleteOne{builder}
}

// Query returns a query builder for Plan.
func (c *PlanClient) Query() *PlanQuery {
	return &PlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlan},
		inters: c.Interceptors(),
	}
}

// Get returns a Plan entity by its id.
func (c *PlanClient) Get(ctx context.Context, id string) (*Plan, error) {
	return c.Query().Where(plan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlanClient) GetX(ctx context.Context, id string) *Plan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubscriptions queries the subscriptions edge of a Plan.
func (c *PlanClient) QuerySubscriptions(_m *Plan) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, plan.SubscriptionsTable, plan.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlanClient) Hooks() []Hook {
	return c.hooks.Plan
}

// Interceptors returns the client interceptors.
func (c *PlanClient) Interceptors() []Interceptor {
	return c.inters.Plan
}

func (c *PlanClient) mutate(ctx context.Context, m *PlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plan mutation op: %q", m.Op())
	}
}

// RawEventClient is a client for the RawEvent schema.
type RawEventClient struct {
	config
}

// NewRawEventClient returns a client for the RawEvent from the given config.
func NewRawEventClient(c config) *RawEventClient {
	return &RawEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rawevent.Hooks(f(g(h())))`.
func (c *RawEventClient) Use(hooks ...Hook) {
	c.hooks.RawEvent = append(c.hooks.RawEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rawevent.Intercept(f(g(h())))`.
func (c *RawEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.RawEvent = append(c.inters.RawEvent, interceptors...)
}

// Create returns a builder for creating a RawEvent entity.
func (c *RawEventClient) Create() *RawEventCreate {
	mutation := newRawEventMutation(c.config, OpCreate)
	return &RawEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RawEvent entities.
func (c *RawEventClient) CreateBulk(builders ...*RawEventCreate) *RawEventCreateBulk {
	return &RawEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RawEventClient) MapCreateBulk(slice any, setFunc func(*RawEventCreate, int)) *RawEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RawEventCreateBulk{err: fmt.Errorf("calling to RawEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RawEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RawEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RawEvent.
func (c *RawEventClient) Update() *RawEventUpdate {
	mutation := newRawEventMutation(c.config, OpUpdate)
	return &RawEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RawEventClient) UpdateOne(_m *RawEvent) *RawEventUpdateOne {
	mutation := newRawEventMutation(c.config, OpUpdateOne, withRawEvent(_m))
	return &RawEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RawEventClient) UpdateOneID(id uuid.UUID) *RawEventUpdateOne {
	mutation := newRawEventMutation(c.config, OpUpdateOne, withRawEventID(id))
	return &RawEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RawEvent.
func (c *RawEventClient) Delete() *RawEventDelete {
	mutation := newRawEventMutation(c.config, OpDelete)
	return &RawEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RawEventClient) DeleteOne(_m *RawEvent) *RawEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RawEventClient) DeleteOneID(id uuid.UUID) *RawEventDeleteOne {
	builder := c.Delete().Where(rawevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RawEventDeleteOne{builder}
}

// Query returns a query builder for RawEvent.
func (c *RawEventClient) Query() *RawEventQuery {
	return &RawEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRawEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a RawEvent entity by its id.
func (c *RawEventClient) Get(ctx context.Context, id uuid.UUID) (*RawEvent, error) {
	return c.Query().Where(rawevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RawEventClient) GetX(ctx context.Context, id uuid.UUID) *RawEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a RawEvent.
func (c *RawEventClient) QuerySession(_m *RawEvent) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rawevent.Table, rawevent.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rawevent.SessionTable, rawevent.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RawEventClient) Hooks() []Hook {
	return c.hooks.RawEvent
}

// Interceptors returns the client interceptors.
func (c *RawEventClient) Interceptors() []Interceptor {
	return c.inters.RawEvent
}

func (c *RawEventClient) mutate(ctx context.Context, m *RawEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RawEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RawEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RawEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RawEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RawEvent mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(_m *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(_m))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id uuid.UUID) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(_m *Session) *SessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id uuid.UUID) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id uuid.UUID) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id uuid.UUID) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Session.
func (c *SessionClient) QueryUser(_m *Session) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.UserTable, session.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPageVisits queries the page_visits edge of a Session.
func (c *SessionClient) QueryPageVisits(_m *Session) *PageVisitQuery {
	query := (&PageVisitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(pagevisit.Table, pagevisit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, session.PageVisitsTable, session.PageVisitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHighlights queries the highlights edge of a Session.
func (c *SessionClient) QueryHighlights(_m *Session) *HighlightQuery {
	query := (&HighlightClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(highlight.Table, highlight.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, session.HighlightsTable, session.HighlightsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRawEvents queries the raw_events edge of a Session.
func (c *SessionClient) QueryRawEvents(_m *Session) *RawEventQuery {
	query := (&RawEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(rawevent.Table, rawevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, session.RawEventsTable, session.RawEventsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMindmap queries the mindmap edge of a Session.
func (c *SessionClient) QueryMindmap(_m *Session) *MindmapGraphQuery {
	query := (&MindmapGraphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(mindmapgraph.Table, mindmapgraph.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, session.MindmapTable, session.MindmapColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokenUsage queries the token_usage edge of a Session.
func (c *SessionClient) QueryTokenUsage(_m *Session) *TokenUsageQuery {
	query := (&TokenUsageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(tokenusage.Table, tokenusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, session.TokenUsageTable, session.TokenUsageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// SubscriptionClient is a client for the Subscription schema.
type SubscriptionClient struct {
	config
}

// NewSubscriptionClient returns a client for the Subscription from the given config.
func NewSubscriptionClient(c config) *SubscriptionClient {
	return &SubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscription.Hooks(f(g(h())))`.
func (c *SubscriptionClient) Use(hooks ...Hook) {
	c.hooks.Subscription = append(c.hooks.Subscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscription.Intercept(f(g(h())))`.
func (c *SubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscription = append(c.inters.Subscription, interceptors...)
}

// Create returns a builder for creating a Subscription entity.
func (c *SubscriptionClient) Create() *SubscriptionCreate {
	mutation := newSubscriptionMutation(c.config, OpCreate)
	return &SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscription entities.
func (c *SubscriptionClient) CreateBulk(builders ...*SubscriptionCreate) *SubscriptionCreateBulk {
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionClient) MapCreateBulk(slice any, setFunc func(*SubscriptionCreate, int)) *SubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionCreateBulk{err: fmt.Errorf("calling to SubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscription.
func (c *SubscriptionClient) Update() *SubscriptionUpdate {
	mutation := newSubscriptionMutation(c.config, OpUpdate)
	return &SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionClient) UpdateOne(_m *Subscription) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscription(_m))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionClient) UpdateOneID(id uuid.UUID) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscriptionID(id))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscription.
func (c *SubscriptionClient) Delete() *SubscriptionDelete {
	mutation := newSubscriptionMutation(c.config, OpDelete)
	return &SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionClient) DeleteOne(_m *Subscription) *SubscriptionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionClient) DeleteOneID(id uuid.UUID) *SubscriptionDeleteOne {
	builder := c.Delete().Where(subscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionDeleteOne{builder}
}

// Query returns a query builder for Subscription.
func (c *SubscriptionClient) Query() *SubscriptionQuery {
	return &SubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscription entity by its id.
func (c *SubscriptionClient) Get(ctx context.Context, id uuid.UUID) (*Subscription, error) {
	return c.Query().Where(subscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionClient) GetX(ctx context.Context, id uuid.UUID) *Subscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Subscription.
func (c *SubscriptionClient) QueryUser(_m *Subscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.UserTable, subscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the plan edge of a Subscription.
func (c *SubscriptionClient) QueryPlan(_m *Subscription) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.PlanTable, subscription.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriptionClient) Hooks() []Hook {
	return c.hooks.Subscription
}

// Interceptors returns the client interceptors.
func (c *SubscriptionClient) Interceptors() []Interceptor {
	return c.inters.Subscription
}

func (c *SubscriptionClient) mutate(ctx context.Context, m *SubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subscription mutation op: %q", m.Op())
	}
}

// TokenUsageClient is a client for the TokenUsage schema.
type TokenUsageClient struct {
	config
}

// NewTokenUsageClient returns a client for the TokenUsage from the given config.
func NewTokenUsageClient(c config) *TokenUsageClient {
	return &TokenUsageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tokenusage.Hooks(f(g(h())))`.
func (c *TokenUsageClient) Use(hooks ...Hook) {
	c.hooks.TokenUsage = append(c.hooks.TokenUsage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tokenusage.Intercept(f(g(h())))`.
func (c *TokenUsageClient) Intercept(interceptors ...Interceptor) {
	c.inters.TokenUsage = append(c.inters.TokenUsage, interceptors...)
}

// Create returns a builder for creating a TokenUsage entity.
func (c *TokenUsageClient) Create() *TokenUsageCreate {
	mutation := newTokenUsageMutation(c.config, OpCreate)
	return &TokenUsageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TokenUsage entities.
func (c *TokenUsageClient) CreateBulk(builders ...*TokenUsageCreate) *TokenUsageCreateBulk {
	return &TokenUsageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenUsageClient) MapCreateBulk(slice any, setFunc func(*TokenUsageCreate, int)) *TokenUsageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenUsageCreateBulk{err: fmt.Errorf("calling to TokenUsageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenUsageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenUsageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TokenUsage.
func (c *TokenUsageClient) Update() *TokenUsageUpdate {
	mutation := newTokenUsageMutation(c.config, OpUpdate)
	return &TokenUsageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenUsageClient) UpdateOne(_m *TokenUsage) *TokenUsageUpdateOne {
	mutation := newTokenUsageMutation(c.config, OpUpdateOne, withTokenUsage(_m))
	return &TokenUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenUsageClient) UpdateOneID(id uuid.UUID) *TokenUsageUpdateOne {
	mutation := newTokenUsageMutation(c.config, OpUpdateOne, withTokenUsageID(id))
	return &TokenUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TokenUsage.
func (c *TokenUsageClient) Delete() *TokenUsageDelete {
	mutation := newTokenUsageMutation(c.config, OpDelete)
	return &TokenUsageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenUsageClient) DeleteOne(_m *TokenUsage) *TokenUsageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenUsageClient) DeleteOneID(id uuid.UUID) *TokenUsageDeleteOne {
	builder := c.Delete().Where(tokenusage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenUsageDeleteOne{builder}
}

// Query returns a query builder for TokenUsage.
func (c *TokenUsageClient) Query() *TokenUsageQuery {
	return &TokenUsageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTokenUsage},
		inters: c.Interceptors(),
	}
}

// Get returns a TokenUsage entity by its id.
func (c *TokenUsageClient) Get(ctx context.Context, id uuid.UUID) (*TokenUsage, error) {
	return c.Query().Where(tokenusage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenUsageClient) GetX(ctx context.Context, id uuid.UUID) *TokenUsage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TokenUsage.
func (c *TokenUsageClient) QueryUser(_m *TokenUsage) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tokenusage.Table, tokenusage.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tokenusage.UserTable, tokenusage.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySession queries the session edge of a TokenUsage.
func (c *TokenUsageClient) QuerySession(_m *TokenUsage) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tokenusage.Table, tokenusage.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tokenusage.SessionTable, tokenusage.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenUsageClient) Hooks() []Hook {
	return c.hooks.TokenUsage
}

// Interceptors returns the client interceptors.
func (c *TokenUsageClient) Interceptors() []Interceptor {
	return c.inters.TokenUsage
}

func (c *TokenUsageClient) mutate(ctx context.Context, m *TokenUsageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenUsageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUsageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenUsageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TokenUsage mutation op: %q", m.Op())
	}
}

// URLClient is a client for the URL schema.
type URLClient struct {
	config
}

// NewURLClient returns a client for the URL from the given config.
func NewURLClient(c config) *URLClient {
	return &URLClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `url.Hooks(f(g(h())))`.
func (c *URLClient) Use(hooks ...Hook) {
	c.hooks.URL = append(c.hooks.URL, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `url.Intercept(f(g(h())))`.
func (c *URLClient) Intercept(interceptors ...Interceptor) {
	c.inters.URL = append(c.inters.URL, interceptors...)
}

// Create returns a builder for creating a URL entity.
func (c *URLClient) Create() *URLCreate {
	mutation := newURLMutation(c.config, OpCreate)
	return &URLCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of URL entities.
func (c *URLClient) CreateBulk(builders ...*URLCreate) *URLCreateBulk {
	return &URLCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *URLClient) MapCreateBulk(slice any, setFunc func(*URLCreate, int)) *URLCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &URLCreateBulk{err: fmt.Errorf("calling to URLClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*URLCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &URLCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for URL.
func (c *URLClient) Update() *URLUpdate {
	mutation := newURLMutation(c.config, OpUpdate)
	return &URLUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *URLClient) UpdateOne(_m *URL) *URLUpdateOne {
	mutation := newURLMutation(c.config, OpUpdateOne, withURL(_m))
	return &URLUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *URLClient) UpdateOneID(id uuid.UUID) *URLUpdateOne {
	mutation := newURLMutation(c.config, OpUpdateOne, withURLID(id))
	return &URLUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for URL.
func (c *URLClient) Delete() *URLDelete {
	mutation := newURLMutation(c.config, OpDelete)
	return &URLDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *URLClient) DeleteOne(_m *URL) *URLDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *URLClient) DeleteOneID(id uuid.UUID) *URLDeleteOne {
	builder := c.Delete().Where(url.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &URLDeleteOne{builder}
}

// Query returns a query builder for URL.
func (c *URLClient) Query() *URLQuery {
	return &URLQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeURL},
		inters: c.Interceptors(),
	}
}

// Get returns a URL entity by its id.
func (c *URLClient) Get(ctx context.Context, id uuid.UUID) (*URL, error) {
	return c.Query().Where(url.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *URLClient) GetX(ctx context.Context, id uuid.UUID) *URL {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPageVisits queries the page_visits edge of a URL.
func (c *URLClient) QueryPageVisits(_m *URL) *PageVisitQuery {
	query := (&PageVisitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(url.Table, url.FieldID, id),
			sqlgraph.To(pagevisit.Table, pagevisit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, url.PageVisitsTable, url.PageVisitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *URLClient) Hooks() []Hook {
	return c.hooks.URL
}

// Interceptors returns the client interceptors.
func (c *URLClient) Interceptors() []Interceptor {
	return c.inters.URL
}

func (c *URLClient) mutate(ctx context.Context, m *URLMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&URLCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&URLUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&URLUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&URLDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown URL mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySettings queries the settings edge of a User.
func (c *UserClient) QuerySettings(_m *User) *UserSettingsQuery {
	query := (&UserSettingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersettings.Table, usersettings.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.SettingsTable, user.SettingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(_m *User) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPasswordResetTokens queries the password_reset_tokens edge of a User.
func (c *UserClient) QueryPasswordResetTokens(_m *User) *PasswordResetTokenQuery {
	query := (&PasswordResetTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(passwordresettoken.Table, passwordresettoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PasswordResetTokensTable, user.PasswordResetTokensColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(_m *User) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokenUsage queries the token_usage edge of a User.
func (c *UserClient) QueryTokenUsage(_m *User) *TokenUsageQuery {
	query := (&TokenUsageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tokenusage.Table, tokenusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TokenUsageTable, user.TokenUsageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserSettingsClient is a client for the UserSettings schema.
type UserSettingsClient struct {
	config
}

// NewUserSettingsClient returns a client for the UserSettings from the given config.
func NewUserSettingsClient(c config) *UserSettingsClient {
	return &UserSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersettings.Hooks(f(g(h())))`.
func (c *UserSettingsClient) Use(hooks ...Hook) {
	c.hooks.UserSettings = append(c.hooks.UserSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersettings.Intercept(f(g(h())))`.
func (c *UserSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSettings = append(c.inters.UserSettings, interceptors...)
}

// Create returns a builder for creating a UserSettings entity.
func (c *UserSettingsClient) Create() *UserSettingsCreate {
	mutation := newUserSettingsMutation(c.config, OpCreate)
	return &UserSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSettings entities.
func (c *UserSettingsClient) CreateBulk(builders ...*UserSettingsCreate) *UserSettingsCreateBulk {
	return &UserSettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSettingsClient) MapCreateBulk(slice any, setFunc func(*UserSettingsCreate, int)) *UserSettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSettingsCreateBulk{err: fmt.Errorf("calling to UserSettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSettings.
func (c *UserSettingsClient) Update() *UserSettingsUpdate {
	mutation := newUserSettingsMutation(c.config, OpUpdate)
	return &UserSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSettingsClient) UpdateOne(_m *UserSettings) *UserSettingsUpdateOne {
	mutation := newUserSettingsMutation(c.config, OpUpdateOne, withUserSettings(_m))
	return &UserSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSettingsClient) UpdateOneID(id uuid.UUID) *UserSettingsUpdateOne {
	mutation := newUserSettingsMutation(c.config, OpUpdateOne, withUserSettingsID(id))
	return &UserSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSettings.
func (c *UserSettingsClient) Delete() *UserSettingsDelete {
	mutation := newUserSettingsMutation(c.config, OpDelete)
	return &UserSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSettingsClient) DeleteOne(_m *UserSettings) *UserSettingsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSettingsClient) DeleteOneID(id uuid.UUID) *UserSettingsDeleteOne {
	builder := c.Delete().Where(usersettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSettingsDeleteOne{builder}
}

// Query returns a query builder for UserSettings.
func (c *UserSettingsClient) Query() *UserSettingsQuery {
	return &UserSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSettings entity by its id.
func (c *UserSettingsClient) Get(ctx context.Context, id uuid.UUID) (*UserSettings, error) {
	return c.Query().Where(usersettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSettingsClient) GetX(ctx context.Context, id uuid.UUID) *UserSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSettings.
func (c *UserSettingsClient) QueryUser(_m *UserSettings) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersettings.Table, usersettings.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, usersettings.UserTable, usersettings.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSettingsClient) Hooks() []Hook {
	return c.hooks.UserSettings
}

// Interceptors returns the client interceptors.
func (c *UserSettingsClient) Interceptors() []Interceptor {
	return c.inters.UserSettings
}

func (c *UserSettingsClient) mutate(ctx context.Context, m *UserSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserSettings mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Highlight, MindmapGraph, PageVisit, PasswordResetToken, Plan, RawEvent, Session,
		Subscription, TokenUsage, URL, User, UserSettings []ent.Hook
	}
	inters struct {
		Highlight, MindmapGraph, PageVisit, PasswordResetToken, Plan, RawEvent, Session,
		Subscription, TokenUsage, URL, User, UserSettings []ent.Interceptor
	}
)
