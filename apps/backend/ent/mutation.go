// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/mindhit/api/ent/highlight"
	"github.com/mindhit/api/ent/mindmapgraph"
	"github.com/mindhit/api/ent/pagevisit"
	"github.com/mindhit/api/ent/passwordresettoken"
	"github.com/mindhit/api/ent/predicate"
	"github.com/mindhit/api/ent/rawevent"
	"github.com/mindhit/api/ent/session"
	"github.com/mindhit/api/ent/url"
	"github.com/mindhit/api/ent/user"
	"github.com/mindhit/api/ent/usersettings"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeHighlight          = "Highlight"
	TypeMindmapGraph       = "MindmapGraph"
	TypePageVisit          = "PageVisit"
	TypePasswordResetToken = "PasswordResetToken"
	TypeRawEvent           = "RawEvent"
	TypeSession            = "Session"
	TypeURL                = "URL"
	TypeUser               = "User"
	TypeUserSettings       = "UserSettings"
)

// HighlightMutation represents an operation that mutates the Highlight nodes in the graph.
type HighlightMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	text              *string
	selector          *string
	color             *string
	note              *string
	clearedFields     map[string]struct{}
	session           *uuid.UUID
	clearedsession    bool
	page_visit        *uuid.UUID
	clearedpage_visit bool
	done              bool
	oldValue          func(context.Context) (*Highlight, error)
	predicates        []predicate.Highlight
}

var _ ent.Mutation = (*HighlightMutation)(nil)

// highlightOption allows management of the mutation configuration using functional options.
type highlightOption func(*HighlightMutation)

// newHighlightMutation creates new mutation for the Highlight entity.
func newHighlightMutation(c config, op Op, opts ...highlightOption) *HighlightMutation {
	m := &HighlightMutation{
		config:        c,
		op:            op,
		typ:           TypeHighlight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHighlightID sets the ID field of the mutation.
func withHighlightID(id uuid.UUID) highlightOption {
	return func(m *HighlightMutation) {
		var (
			err   error
			once  sync.Once
			value *Highlight
		)
		m.oldValue = func(ctx context.Context) (*Highlight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Highlight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHighlight sets the old Highlight of the mutation.
func withHighlight(node *Highlight) highlightOption {
	return func(m *HighlightMutation) {
		m.oldValue = func(context.Context) (*Highlight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HighlightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HighlightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Highlight entities.
func (m *HighlightMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HighlightMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HighlightMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Highlight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HighlightMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HighlightMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Highlight entity.
// If the Highlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HighlightMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HighlightMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HighlightMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HighlightMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Highlight entity.
// If the Highlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HighlightMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HighlightMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetText sets the "text" field.
func (m *HighlightMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *HighlightMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Highlight entity.
// If the Highlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HighlightMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *HighlightMutation) ResetText() {
	m.text = nil
}

// SetSelector sets the "selector" field.
func (m *HighlightMutation) SetSelector(s string) {
	m.selector = &s
}

// Selector returns the value of the "selector" field in the mutation.
func (m *HighlightMutation) Selector() (r string, exists bool) {
	v := m.selector
	if v == nil {
		return
	}
	return *v, true
}

// OldSelector returns the old "selector" field's value of the Highlight entity.
// If the Highlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HighlightMutation) OldSelector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelector: %w", err)
	}
	return oldValue.Selector, nil
}

// ClearSelector clears the value of the "selector" field.
func (m *HighlightMutation) ClearSelector() {
	m.selector = nil
	m.clearedFields[highlight.FieldSelector] = struct{}{}
}

// SelectorCleared returns if the "selector" field was cleared in this mutation.
func (m *HighlightMutation) SelectorCleared() bool {
	_, ok := m.clearedFields[highlight.FieldSelector]
	return ok
}

// ResetSelector resets all changes to the "selector" field.
func (m *HighlightMutation) ResetSelector() {
	m.selector = nil
	delete(m.clearedFields, highlight.FieldSelector)
}

// SetColor sets the "color" field.
func (m *HighlightMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *HighlightMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Highlight entity.
// If the Highlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HighlightMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *HighlightMutation) ResetColor() {
	m.color = nil
}

// SetNote sets the "note" field.
func (m *HighlightMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *HighlightMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Highlight entity.
// If the Highlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HighlightMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *HighlightMutation) ClearNote() {
	m.note = nil
	m.clearedFields[highlight.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *HighlightMutation) NoteCleared() bool {
	_, ok := m.clearedFields[highlight.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *HighlightMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, highlight.FieldNote)
}

// SetSessionID sets the "session" edge to the Session entity by id.
func (m *HighlightMutation) SetSessionID(id uuid.UUID) {
	m.session = &id
}

// ClearSession clears the "session" edge to the Session entity.
func (m *HighlightMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *HighlightMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *HighlightMutation) SessionID() (id uuid.UUID, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *HighlightMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *HighlightMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// SetPageVisitID sets the "page_visit" edge to the PageVisit entity by id.
func (m *HighlightMutation) SetPageVisitID(id uuid.UUID) {
	m.page_visit = &id
}

// ClearPageVisit clears the "page_visit" edge to the PageVisit entity.
func (m *HighlightMutation) ClearPageVisit() {
	m.clearedpage_visit = true
}

// PageVisitCleared reports if the "page_visit" edge to the PageVisit entity was cleared.
func (m *HighlightMutation) PageVisitCleared() bool {
	return m.clearedpage_visit
}

// PageVisitID returns the "page_visit" edge ID in the mutation.
func (m *HighlightMutation) PageVisitID() (id uuid.UUID, exists bool) {
	if m.page_visit != nil {
		return *m.page_visit, true
	}
	return
}

// PageVisitIDs returns the "page_visit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PageVisitID instead. It exists only for internal usage by the builders.
func (m *HighlightMutation) PageVisitIDs() (ids []uuid.UUID) {
	if id := m.page_visit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPageVisit resets all changes to the "page_visit" edge.
func (m *HighlightMutation) ResetPageVisit() {
	m.page_visit = nil
	m.clearedpage_visit = false
}

// Where appends a list predicates to the HighlightMutation builder.
func (m *HighlightMutation) Where(ps ...predicate.Highlight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HighlightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HighlightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Highlight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HighlightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HighlightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Highlight).
func (m *HighlightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HighlightMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, highlight.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, highlight.FieldUpdatedAt)
	}
	if m.text != nil {
		fields = append(fields, highlight.FieldText)
	}
	if m.selector != nil {
		fields = append(fields, highlight.FieldSelector)
	}
	if m.color != nil {
		fields = append(fields, highlight.FieldColor)
	}
	if m.note != nil {
		fields = append(fields, highlight.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HighlightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case highlight.FieldCreatedAt:
		return m.CreatedAt()
	case highlight.FieldUpdatedAt:
		return m.UpdatedAt()
	case highlight.FieldText:
		return m.Text()
	case highlight.FieldSelector:
		return m.Selector()
	case highlight.FieldColor:
		return m.Color()
	case highlight.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HighlightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case highlight.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case highlight.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case highlight.FieldText:
		return m.OldText(ctx)
	case highlight.FieldSelector:
		return m.OldSelector(ctx)
	case highlight.FieldColor:
		return m.OldColor(ctx)
	case highlight.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown Highlight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HighlightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case highlight.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case highlight.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case highlight.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case highlight.FieldSelector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelector(v)
		return nil
	case highlight.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case highlight.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown Highlight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HighlightMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HighlightMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HighlightMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Highlight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HighlightMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(highlight.FieldSelector) {
		fields = append(fields, highlight.FieldSelector)
	}
	if m.FieldCleared(highlight.FieldNote) {
		fields = append(fields, highlight.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HighlightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HighlightMutation) ClearField(name string) error {
	switch name {
	case highlight.FieldSelector:
		m.ClearSelector()
		return nil
	case highlight.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Highlight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HighlightMutation) ResetField(name string) error {
	switch name {
	case highlight.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case highlight.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case highlight.FieldText:
		m.ResetText()
		return nil
	case highlight.FieldSelector:
		m.ResetSelector()
		return nil
	case highlight.FieldColor:
		m.ResetColor()
		return nil
	case highlight.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown Highlight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HighlightMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.session != nil {
		edges = append(edges, highlight.EdgeSession)
	}
	if m.page_visit != nil {
		edges = append(edges, highlight.EdgePageVisit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HighlightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case highlight.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case highlight.EdgePageVisit:
		if id := m.page_visit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HighlightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HighlightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HighlightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsession {
		edges = append(edges, highlight.EdgeSession)
	}
	if m.clearedpage_visit {
		edges = append(edges, highlight.EdgePageVisit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HighlightMutation) EdgeCleared(name string) bool {
	switch name {
	case highlight.EdgeSession:
		return m.clearedsession
	case highlight.EdgePageVisit:
		return m.clearedpage_visit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HighlightMutation) ClearEdge(name string) error {
	switch name {
	case highlight.EdgeSession:
		m.ClearSession()
		return nil
	case highlight.EdgePageVisit:
		m.ClearPageVisit()
		return nil
	}
	return fmt.Errorf("unknown Highlight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HighlightMutation) ResetEdge(name string) error {
	switch name {
	case highlight.EdgeSession:
		m.ResetSession()
		return nil
	case highlight.EdgePageVisit:
		m.ResetPageVisit()
		return nil
	}
	return fmt.Errorf("unknown Highlight edge %s", name)
}

// MindmapGraphMutation represents an operation that mutates the MindmapGraph nodes in the graph.
type MindmapGraphMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	nodes             *[]map[string]interface{}
	appendnodes       []map[string]interface{}
	graph_edges       *[]map[string]interface{}
	appendgraph_edges []map[string]interface{}
	layout            *map[string]interface{}
	generated_at      *time.Time
	version           *int
	addversion        *int
	clearedFields     map[string]struct{}
	session           *uuid.UUID
	clearedsession    bool
	done              bool
	oldValue          func(context.Context) (*MindmapGraph, error)
	predicates        []predicate.MindmapGraph
}

var _ ent.Mutation = (*MindmapGraphMutation)(nil)

// mindmapgraphOption allows management of the mutation configuration using functional options.
type mindmapgraphOption func(*MindmapGraphMutation)

// newMindmapGraphMutation creates new mutation for the MindmapGraph entity.
func newMindmapGraphMutation(c config, op Op, opts ...mindmapgraphOption) *MindmapGraphMutation {
	m := &MindmapGraphMutation{
		config:        c,
		op:            op,
		typ:           TypeMindmapGraph,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMindmapGraphID sets the ID field of the mutation.
func withMindmapGraphID(id uuid.UUID) mindmapgraphOption {
	return func(m *MindmapGraphMutation) {
		var (
			err   error
			once  sync.Once
			value *MindmapGraph
		)
		m.oldValue = func(ctx context.Context) (*MindmapGraph, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MindmapGraph.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMindmapGraph sets the old MindmapGraph of the mutation.
func withMindmapGraph(node *MindmapGraph) mindmapgraphOption {
	return func(m *MindmapGraphMutation) {
		m.oldValue = func(context.Context) (*MindmapGraph, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MindmapGraphMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MindmapGraphMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MindmapGraph entities.
func (m *MindmapGraphMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MindmapGraphMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MindmapGraphMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MindmapGraph.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MindmapGraphMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MindmapGraphMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MindmapGraph entity.
// If the MindmapGraph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapGraphMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MindmapGraphMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MindmapGraphMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MindmapGraphMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MindmapGraph entity.
// If the MindmapGraph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapGraphMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MindmapGraphMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNodes sets the "nodes" field.
func (m *MindmapGraphMutation) SetNodes(value []map[string]interface{}) {
	m.nodes = &value
	m.appendnodes = nil
}

// Nodes returns the value of the "nodes" field in the mutation.
func (m *MindmapGraphMutation) Nodes() (r []map[string]interface{}, exists bool) {
	v := m.nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldNodes returns the old "nodes" field's value of the MindmapGraph entity.
// If the MindmapGraph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapGraphMutation) OldNodes(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodes: %w", err)
	}
	return oldValue.Nodes, nil
}

// AppendNodes adds value to the "nodes" field.
func (m *MindmapGraphMutation) AppendNodes(value []map[string]interface{}) {
	m.appendnodes = append(m.appendnodes, value...)
}

// AppendedNodes returns the list of values that were appended to the "nodes" field in this mutation.
func (m *MindmapGraphMutation) AppendedNodes() ([]map[string]interface{}, bool) {
	if len(m.appendnodes) == 0 {
		return nil, false
	}
	return m.appendnodes, true
}

// ClearNodes clears the value of the "nodes" field.
func (m *MindmapGraphMutation) ClearNodes() {
	m.nodes = nil
	m.appendnodes = nil
	m.clearedFields[mindmapgraph.FieldNodes] = struct{}{}
}

// NodesCleared returns if the "nodes" field was cleared in this mutation.
func (m *MindmapGraphMutation) NodesCleared() bool {
	_, ok := m.clearedFields[mindmapgraph.FieldNodes]
	return ok
}

// ResetNodes resets all changes to the "nodes" field.
func (m *MindmapGraphMutation) ResetNodes() {
	m.nodes = nil
	m.appendnodes = nil
	delete(m.clearedFields, mindmapgraph.FieldNodes)
}

// SetGraphEdges sets the "graph_edges" field.
func (m *MindmapGraphMutation) SetGraphEdges(value []map[string]interface{}) {
	m.graph_edges = &value
	m.appendgraph_edges = nil
}

// GraphEdges returns the value of the "graph_edges" field in the mutation.
func (m *MindmapGraphMutation) GraphEdges() (r []map[string]interface{}, exists bool) {
	v := m.graph_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldGraphEdges returns the old "graph_edges" field's value of the MindmapGraph entity.
// If the MindmapGraph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapGraphMutation) OldGraphEdges(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGraphEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGraphEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGraphEdges: %w", err)
	}
	return oldValue.GraphEdges, nil
}

// AppendGraphEdges adds value to the "graph_edges" field.
func (m *MindmapGraphMutation) AppendGraphEdges(value []map[string]interface{}) {
	m.appendgraph_edges = append(m.appendgraph_edges, value...)
}

// AppendedGraphEdges returns the list of values that were appended to the "graph_edges" field in this mutation.
func (m *MindmapGraphMutation) AppendedGraphEdges() ([]map[string]interface{}, bool) {
	if len(m.appendgraph_edges) == 0 {
		return nil, false
	}
	return m.appendgraph_edges, true
}

// ClearGraphEdges clears the value of the "graph_edges" field.
func (m *MindmapGraphMutation) ClearGraphEdges() {
	m.graph_edges = nil
	m.appendgraph_edges = nil
	m.clearedFields[mindmapgraph.FieldGraphEdges] = struct{}{}
}

// GraphEdgesCleared returns if the "graph_edges" field was cleared in this mutation.
func (m *MindmapGraphMutation) GraphEdgesCleared() bool {
	_, ok := m.clearedFields[mindmapgraph.FieldGraphEdges]
	return ok
}

// ResetGraphEdges resets all changes to the "graph_edges" field.
func (m *MindmapGraphMutation) ResetGraphEdges() {
	m.graph_edges = nil
	m.appendgraph_edges = nil
	delete(m.clearedFields, mindmapgraph.FieldGraphEdges)
}

// SetLayout sets the "layout" field.
func (m *MindmapGraphMutation) SetLayout(value map[string]interface{}) {
	m.layout = &value
}

// Layout returns the value of the "layout" field in the mutation.
func (m *MindmapGraphMutation) Layout() (r map[string]interface{}, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the MindmapGraph entity.
// If the MindmapGraph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapGraphMutation) OldLayout(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ClearLayout clears the value of the "layout" field.
func (m *MindmapGraphMutation) ClearLayout() {
	m.layout = nil
	m.clearedFields[mindmapgraph.FieldLayout] = struct{}{}
}

// LayoutCleared returns if the "layout" field was cleared in this mutation.
func (m *MindmapGraphMutation) LayoutCleared() bool {
	_, ok := m.clearedFields[mindmapgraph.FieldLayout]
	return ok
}

// ResetLayout resets all changes to the "layout" field.
func (m *MindmapGraphMutation) ResetLayout() {
	m.layout = nil
	delete(m.clearedFields, mindmapgraph.FieldLayout)
}

// SetGeneratedAt sets the "generated_at" field.
func (m *MindmapGraphMutation) SetGeneratedAt(t time.Time) {
	m.generated_at = &t
}

// GeneratedAt returns the value of the "generated_at" field in the mutation.
func (m *MindmapGraphMutation) GeneratedAt() (r time.Time, exists bool) {
	v := m.generated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedAt returns the old "generated_at" field's value of the MindmapGraph entity.
// If the MindmapGraph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapGraphMutation) OldGeneratedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedAt: %w", err)
	}
	return oldValue.GeneratedAt, nil
}

// ResetGeneratedAt resets all changes to the "generated_at" field.
func (m *MindmapGraphMutation) ResetGeneratedAt() {
	m.generated_at = nil
}

// SetVersion sets the "version" field.
func (m *MindmapGraphMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *MindmapGraphMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the MindmapGraph entity.
// If the MindmapGraph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MindmapGraphMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *MindmapGraphMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *MindmapGraphMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *MindmapGraphMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetSessionID sets the "session" edge to the Session entity by id.
func (m *MindmapGraphMutation) SetSessionID(id uuid.UUID) {
	m.session = &id
}

// ClearSession clears the "session" edge to the Session entity.
func (m *MindmapGraphMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *MindmapGraphMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *MindmapGraphMutation) SessionID() (id uuid.UUID, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *MindmapGraphMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *MindmapGraphMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the MindmapGraphMutation builder.
func (m *MindmapGraphMutation) Where(ps ...predicate.MindmapGraph) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MindmapGraphMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MindmapGraphMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MindmapGraph, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MindmapGraphMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MindmapGraphMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MindmapGraph).
func (m *MindmapGraphMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MindmapGraphMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, mindmapgraph.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mindmapgraph.FieldUpdatedAt)
	}
	if m.nodes != nil {
		fields = append(fields, mindmapgraph.FieldNodes)
	}
	if m.graph_edges != nil {
		fields = append(fields, mindmapgraph.FieldGraphEdges)
	}
	if m.layout != nil {
		fields = append(fields, mindmapgraph.FieldLayout)
	}
	if m.generated_at != nil {
		fields = append(fields, mindmapgraph.FieldGeneratedAt)
	}
	if m.version != nil {
		fields = append(fields, mindmapgraph.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MindmapGraphMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mindmapgraph.FieldCreatedAt:
		return m.CreatedAt()
	case mindmapgraph.FieldUpdatedAt:
		return m.UpdatedAt()
	case mindmapgraph.FieldNodes:
		return m.Nodes()
	case mindmapgraph.FieldGraphEdges:
		return m.GraphEdges()
	case mindmapgraph.FieldLayout:
		return m.Layout()
	case mindmapgraph.FieldGeneratedAt:
		return m.GeneratedAt()
	case mindmapgraph.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MindmapGraphMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mindmapgraph.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mindmapgraph.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mindmapgraph.FieldNodes:
		return m.OldNodes(ctx)
	case mindmapgraph.FieldGraphEdges:
		return m.OldGraphEdges(ctx)
	case mindmapgraph.FieldLayout:
		return m.OldLayout(ctx)
	case mindmapgraph.FieldGeneratedAt:
		return m.OldGeneratedAt(ctx)
	case mindmapgraph.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown MindmapGraph field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MindmapGraphMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mindmapgraph.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mindmapgraph.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mindmapgraph.FieldNodes:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodes(v)
		return nil
	case mindmapgraph.FieldGraphEdges:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGraphEdges(v)
		return nil
	case mindmapgraph.FieldLayout:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case mindmapgraph.FieldGeneratedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedAt(v)
		return nil
	case mindmapgraph.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown MindmapGraph field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MindmapGraphMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, mindmapgraph.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MindmapGraphMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mindmapgraph.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MindmapGraphMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mindmapgraph.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown MindmapGraph numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MindmapGraphMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mindmapgraph.FieldNodes) {
		fields = append(fields, mindmapgraph.FieldNodes)
	}
	if m.FieldCleared(mindmapgraph.FieldGraphEdges) {
		fields = append(fields, mindmapgraph.FieldGraphEdges)
	}
	if m.FieldCleared(mindmapgraph.FieldLayout) {
		fields = append(fields, mindmapgraph.FieldLayout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MindmapGraphMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MindmapGraphMutation) ClearField(name string) error {
	switch name {
	case mindmapgraph.FieldNodes:
		m.ClearNodes()
		return nil
	case mindmapgraph.FieldGraphEdges:
		m.ClearGraphEdges()
		return nil
	case mindmapgraph.FieldLayout:
		m.ClearLayout()
		return nil
	}
	return fmt.Errorf("unknown MindmapGraph nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MindmapGraphMutation) ResetField(name string) error {
	switch name {
	case mindmapgraph.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mindmapgraph.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mindmapgraph.FieldNodes:
		m.ResetNodes()
		return nil
	case mindmapgraph.FieldGraphEdges:
		m.ResetGraphEdges()
		return nil
	case mindmapgraph.FieldLayout:
		m.ResetLayout()
		return nil
	case mindmapgraph.FieldGeneratedAt:
		m.ResetGeneratedAt()
		return nil
	case mindmapgraph.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown MindmapGraph field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MindmapGraphMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, mindmapgraph.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MindmapGraphMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mindmapgraph.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MindmapGraphMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MindmapGraphMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MindmapGraphMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, mindmapgraph.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MindmapGraphMutation) EdgeCleared(name string) bool {
	switch name {
	case mindmapgraph.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MindmapGraphMutation) ClearEdge(name string) error {
	switch name {
	case mindmapgraph.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown MindmapGraph unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MindmapGraphMutation) ResetEdge(name string) error {
	switch name {
	case mindmapgraph.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown MindmapGraph edge %s", name)
}

// PageVisitMutation represents an operation that mutates the PageVisit nodes in the graph.
type PageVisitMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	entered_at          *time.Time
	left_at             *time.Time
	duration_ms         *int
	addduration_ms      *int
	max_scroll_depth    *float64
	addmax_scroll_depth *float64
	clearedFields       map[string]struct{}
	session             *uuid.UUID
	clearedsession      bool
	url                 *uuid.UUID
	clearedurl          bool
	done                bool
	oldValue            func(context.Context) (*PageVisit, error)
	predicates          []predicate.PageVisit
}

var _ ent.Mutation = (*PageVisitMutation)(nil)

// pagevisitOption allows management of the mutation configuration using functional options.
type pagevisitOption func(*PageVisitMutation)

// newPageVisitMutation creates new mutation for the PageVisit entity.
func newPageVisitMutation(c config, op Op, opts ...pagevisitOption) *PageVisitMutation {
	m := &PageVisitMutation{
		config:        c,
		op:            op,
		typ:           TypePageVisit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageVisitID sets the ID field of the mutation.
func withPageVisitID(id uuid.UUID) pagevisitOption {
	return func(m *PageVisitMutation) {
		var (
			err   error
			once  sync.Once
			value *PageVisit
		)
		m.oldValue = func(ctx context.Context) (*PageVisit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PageVisit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPageVisit sets the old PageVisit of the mutation.
func withPageVisit(node *PageVisit) pagevisitOption {
	return func(m *PageVisitMutation) {
		m.oldValue = func(context.Context) (*PageVisit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageVisitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageVisitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PageVisit entities.
func (m *PageVisitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PageVisitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PageVisitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PageVisit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PageVisitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PageVisitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PageVisit entity.
// If the PageVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVisitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PageVisitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PageVisitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PageVisitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PageVisit entity.
// If the PageVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVisitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PageVisitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEnteredAt sets the "entered_at" field.
func (m *PageVisitMutation) SetEnteredAt(t time.Time) {
	m.entered_at = &t
}

// EnteredAt returns the value of the "entered_at" field in the mutation.
func (m *PageVisitMutation) EnteredAt() (r time.Time, exists bool) {
	v := m.entered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEnteredAt returns the old "entered_at" field's value of the PageVisit entity.
// If the PageVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVisitMutation) OldEnteredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnteredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnteredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnteredAt: %w", err)
	}
	return oldValue.EnteredAt, nil
}

// ResetEnteredAt resets all changes to the "entered_at" field.
func (m *PageVisitMutation) ResetEnteredAt() {
	m.entered_at = nil
}

// SetLeftAt sets the "left_at" field.
func (m *PageVisitMutation) SetLeftAt(t time.Time) {
	m.left_at = &t
}

// LeftAt returns the value of the "left_at" field in the mutation.
func (m *PageVisitMutation) LeftAt() (r time.Time, exists bool) {
	v := m.left_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLeftAt returns the old "left_at" field's value of the PageVisit entity.
// If the PageVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVisitMutation) OldLeftAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeftAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeftAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeftAt: %w", err)
	}
	return oldValue.LeftAt, nil
}

// ClearLeftAt clears the value of the "left_at" field.
func (m *PageVisitMutation) ClearLeftAt() {
	m.left_at = nil
	m.clearedFields[pagevisit.FieldLeftAt] = struct{}{}
}

// LeftAtCleared returns if the "left_at" field was cleared in this mutation.
func (m *PageVisitMutation) LeftAtCleared() bool {
	_, ok := m.clearedFields[pagevisit.FieldLeftAt]
	return ok
}

// ResetLeftAt resets all changes to the "left_at" field.
func (m *PageVisitMutation) ResetLeftAt() {
	m.left_at = nil
	delete(m.clearedFields, pagevisit.FieldLeftAt)
}

// SetDurationMs sets the "duration_ms" field.
func (m *PageVisitMutation) SetDurationMs(i int) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *PageVisitMutation) DurationMs() (r int, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the PageVisit entity.
// If the PageVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVisitMutation) OldDurationMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *PageVisitMutation) AddDurationMs(i int) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *PageVisitMutation) AddedDurationMs() (r int, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *PageVisitMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[pagevisit.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *PageVisitMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[pagevisit.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *PageVisitMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, pagevisit.FieldDurationMs)
}

// SetMaxScrollDepth sets the "max_scroll_depth" field.
func (m *PageVisitMutation) SetMaxScrollDepth(f float64) {
	m.max_scroll_depth = &f
	m.addmax_scroll_depth = nil
}

// MaxScrollDepth returns the value of the "max_scroll_depth" field in the mutation.
func (m *PageVisitMutation) MaxScrollDepth() (r float64, exists bool) {
	v := m.max_scroll_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxScrollDepth returns the old "max_scroll_depth" field's value of the PageVisit entity.
// If the PageVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVisitMutation) OldMaxScrollDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxScrollDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxScrollDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxScrollDepth: %w", err)
	}
	return oldValue.MaxScrollDepth, nil
}

// AddMaxScrollDepth adds f to the "max_scroll_depth" field.
func (m *PageVisitMutation) AddMaxScrollDepth(f float64) {
	if m.addmax_scroll_depth != nil {
		*m.addmax_scroll_depth += f
	} else {
		m.addmax_scroll_depth = &f
	}
}

// AddedMaxScrollDepth returns the value that was added to the "max_scroll_depth" field in this mutation.
func (m *PageVisitMutation) AddedMaxScrollDepth() (r float64, exists bool) {
	v := m.addmax_scroll_depth
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxScrollDepth resets all changes to the "max_scroll_depth" field.
func (m *PageVisitMutation) ResetMaxScrollDepth() {
	m.max_scroll_depth = nil
	m.addmax_scroll_depth = nil
}

// SetSessionID sets the "session" edge to the Session entity by id.
func (m *PageVisitMutation) SetSessionID(id uuid.UUID) {
	m.session = &id
}

// ClearSession clears the "session" edge to the Session entity.
func (m *PageVisitMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *PageVisitMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *PageVisitMutation) SessionID() (id uuid.UUID, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *PageVisitMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *PageVisitMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// SetURLID sets the "url" edge to the URL entity by id.
func (m *PageVisitMutation) SetURLID(id uuid.UUID) {
	m.url = &id
}

// ClearURL clears the "url" edge to the URL entity.
func (m *PageVisitMutation) ClearURL() {
	m.clearedurl = true
}

// URLCleared reports if the "url" edge to the URL entity was cleared.
func (m *PageVisitMutation) URLCleared() bool {
	return m.clearedurl
}

// URLID returns the "url" edge ID in the mutation.
func (m *PageVisitMutation) URLID() (id uuid.UUID, exists bool) {
	if m.url != nil {
		return *m.url, true
	}
	return
}

// URLIDs returns the "url" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// URLID instead. It exists only for internal usage by the builders.
func (m *PageVisitMutation) URLIDs() (ids []uuid.UUID) {
	if id := m.url; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetURL resets all changes to the "url" edge.
func (m *PageVisitMutation) ResetURL() {
	m.url = nil
	m.clearedurl = false
}

// Where appends a list predicates to the PageVisitMutation builder.
func (m *PageVisitMutation) Where(ps ...predicate.PageVisit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PageVisitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PageVisitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PageVisit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PageVisitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PageVisitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PageVisit).
func (m *PageVisitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PageVisitMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, pagevisit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pagevisit.FieldUpdatedAt)
	}
	if m.entered_at != nil {
		fields = append(fields, pagevisit.FieldEnteredAt)
	}
	if m.left_at != nil {
		fields = append(fields, pagevisit.FieldLeftAt)
	}
	if m.duration_ms != nil {
		fields = append(fields, pagevisit.FieldDurationMs)
	}
	if m.max_scroll_depth != nil {
		fields = append(fields, pagevisit.FieldMaxScrollDepth)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PageVisitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pagevisit.FieldCreatedAt:
		return m.CreatedAt()
	case pagevisit.FieldUpdatedAt:
		return m.UpdatedAt()
	case pagevisit.FieldEnteredAt:
		return m.EnteredAt()
	case pagevisit.FieldLeftAt:
		return m.LeftAt()
	case pagevisit.FieldDurationMs:
		return m.DurationMs()
	case pagevisit.FieldMaxScrollDepth:
		return m.MaxScrollDepth()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PageVisitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pagevisit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pagevisit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pagevisit.FieldEnteredAt:
		return m.OldEnteredAt(ctx)
	case pagevisit.FieldLeftAt:
		return m.OldLeftAt(ctx)
	case pagevisit.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case pagevisit.FieldMaxScrollDepth:
		return m.OldMaxScrollDepth(ctx)
	}
	return nil, fmt.Errorf("unknown PageVisit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageVisitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pagevisit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pagevisit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pagevisit.FieldEnteredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnteredAt(v)
		return nil
	case pagevisit.FieldLeftAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeftAt(v)
		return nil
	case pagevisit.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case pagevisit.FieldMaxScrollDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxScrollDepth(v)
		return nil
	}
	return fmt.Errorf("unknown PageVisit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PageVisitMutation) AddedFields() []string {
	var fields []string
	if m.addduration_ms != nil {
		fields = append(fields, pagevisit.FieldDurationMs)
	}
	if m.addmax_scroll_depth != nil {
		fields = append(fields, pagevisit.FieldMaxScrollDepth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PageVisitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pagevisit.FieldDurationMs:
		return m.AddedDurationMs()
	case pagevisit.FieldMaxScrollDepth:
		return m.AddedMaxScrollDepth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageVisitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pagevisit.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	case pagevisit.FieldMaxScrollDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxScrollDepth(v)
		return nil
	}
	return fmt.Errorf("unknown PageVisit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PageVisitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pagevisit.FieldLeftAt) {
		fields = append(fields, pagevisit.FieldLeftAt)
	}
	if m.FieldCleared(pagevisit.FieldDurationMs) {
		fields = append(fields, pagevisit.FieldDurationMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PageVisitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageVisitMutation) ClearField(name string) error {
	switch name {
	case pagevisit.FieldLeftAt:
		m.ClearLeftAt()
		return nil
	case pagevisit.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	}
	return fmt.Errorf("unknown PageVisit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PageVisitMutation) ResetField(name string) error {
	switch name {
	case pagevisit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pagevisit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pagevisit.FieldEnteredAt:
		m.ResetEnteredAt()
		return nil
	case pagevisit.FieldLeftAt:
		m.ResetLeftAt()
		return nil
	case pagevisit.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case pagevisit.FieldMaxScrollDepth:
		m.ResetMaxScrollDepth()
		return nil
	}
	return fmt.Errorf("unknown PageVisit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PageVisitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.session != nil {
		edges = append(edges, pagevisit.EdgeSession)
	}
	if m.url != nil {
		edges = append(edges, pagevisit.EdgeURL)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PageVisitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pagevisit.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case pagevisit.EdgeURL:
		if id := m.url; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PageVisitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PageVisitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PageVisitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsession {
		edges = append(edges, pagevisit.EdgeSession)
	}
	if m.clearedurl {
		edges = append(edges, pagevisit.EdgeURL)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PageVisitMutation) EdgeCleared(name string) bool {
	switch name {
	case pagevisit.EdgeSession:
		return m.clearedsession
	case pagevisit.EdgeURL:
		return m.clearedurl
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PageVisitMutation) ClearEdge(name string) error {
	switch name {
	case pagevisit.EdgeSession:
		m.ClearSession()
		return nil
	case pagevisit.EdgeURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown PageVisit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PageVisitMutation) ResetEdge(name string) error {
	switch name {
	case pagevisit.EdgeSession:
		m.ResetSession()
		return nil
	case pagevisit.EdgeURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown PageVisit edge %s", name)
}

// PasswordResetTokenMutation represents an operation that mutates the PasswordResetToken nodes in the graph.
type PasswordResetTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	token         *string
	expires_at    *time.Time
	created_at    *time.Time
	used          *bool
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PasswordResetToken, error)
	predicates    []predicate.PasswordResetToken
}

var _ ent.Mutation = (*PasswordResetTokenMutation)(nil)

// passwordresettokenOption allows management of the mutation configuration using functional options.
type passwordresettokenOption func(*PasswordResetTokenMutation)

// newPasswordResetTokenMutation creates new mutation for the PasswordResetToken entity.
func newPasswordResetTokenMutation(c config, op Op, opts ...passwordresettokenOption) *PasswordResetTokenMutation {
	m := &PasswordResetTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordResetToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordResetTokenID sets the ID field of the mutation.
func withPasswordResetTokenID(id uuid.UUID) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordResetToken
		)
		m.oldValue = func(ctx context.Context) (*PasswordResetToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordResetToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordResetToken sets the old PasswordResetToken of the mutation.
func withPasswordResetToken(node *PasswordResetToken) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		m.oldValue = func(context.Context) (*PasswordResetToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordResetTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordResetTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PasswordResetToken entities.
func (m *PasswordResetTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordResetTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordResetTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordResetToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *PasswordResetTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *PasswordResetTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *PasswordResetTokenMutation) ResetToken() {
	m.token = nil
}

// SetUserID sets the "user_id" field.
func (m *PasswordResetTokenMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasswordResetTokenMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasswordResetTokenMutation) ResetUserID() {
	m.user = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *PasswordResetTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PasswordResetTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PasswordResetTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordResetTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordResetTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordResetTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUsed sets the "used" field.
func (m *PasswordResetTokenMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *PasswordResetTokenMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *PasswordResetTokenMutation) ResetUsed() {
	m.used = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordResetTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passwordresettoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordResetTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordResetTokenMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordResetTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordResetTokenMutation builder.
func (m *PasswordResetTokenMutation) Where(ps ...predicate.PasswordResetToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordResetTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordResetTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordResetToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordResetTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordResetTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordResetToken).
func (m *PasswordResetTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordResetTokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.token != nil {
		fields = append(fields, passwordresettoken.FieldToken)
	}
	if m.user != nil {
		fields = append(fields, passwordresettoken.FieldUserID)
	}
	if m.expires_at != nil {
		fields = append(fields, passwordresettoken.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, passwordresettoken.FieldCreatedAt)
	}
	if m.used != nil {
		fields = append(fields, passwordresettoken.FieldUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordResetTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordresettoken.FieldToken:
		return m.Token()
	case passwordresettoken.FieldUserID:
		return m.UserID()
	case passwordresettoken.FieldExpiresAt:
		return m.ExpiresAt()
	case passwordresettoken.FieldCreatedAt:
		return m.CreatedAt()
	case passwordresettoken.FieldUsed:
		return m.Used()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordResetTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordresettoken.FieldToken:
		return m.OldToken(ctx)
	case passwordresettoken.FieldUserID:
		return m.OldUserID(ctx)
	case passwordresettoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case passwordresettoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passwordresettoken.FieldUsed:
		return m.OldUsed(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordresettoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case passwordresettoken.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passwordresettoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case passwordresettoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passwordresettoken.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordResetTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordResetTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordResetToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordResetTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordResetTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PasswordResetToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetField(name string) error {
	switch name {
	case passwordresettoken.FieldToken:
		m.ResetToken()
		return nil
	case passwordresettoken.FieldUserID:
		m.ResetUserID()
		return nil
	case passwordresettoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case passwordresettoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passwordresettoken.FieldUsed:
		m.ResetUsed()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordResetTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passwordresettoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordResetTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordresettoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordResetTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordResetTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordResetTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passwordresettoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordResetTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordresettoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken edge %s", name)
}

// RawEventMutation represents an operation that mutates the RawEvent nodes in the graph.
type RawEventMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	event_type     *string
	timestamp      *time.Time
	payload        *string
	processed      *bool
	processed_at   *time.Time
	clearedFields  map[string]struct{}
	session        *uuid.UUID
	clearedsession bool
	done           bool
	oldValue       func(context.Context) (*RawEvent, error)
	predicates     []predicate.RawEvent
}

var _ ent.Mutation = (*RawEventMutation)(nil)

// raweventOption allows management of the mutation configuration using functional options.
type raweventOption func(*RawEventMutation)

// newRawEventMutation creates new mutation for the RawEvent entity.
func newRawEventMutation(c config, op Op, opts ...raweventOption) *RawEventMutation {
	m := &RawEventMutation{
		config:        c,
		op:            op,
		typ:           TypeRawEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRawEventID sets the ID field of the mutation.
func withRawEventID(id uuid.UUID) raweventOption {
	return func(m *RawEventMutation) {
		var (
			err   error
			once  sync.Once
			value *RawEvent
		)
		m.oldValue = func(ctx context.Context) (*RawEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RawEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRawEvent sets the old RawEvent of the mutation.
func withRawEvent(node *RawEvent) raweventOption {
	return func(m *RawEventMutation) {
		m.oldValue = func(context.Context) (*RawEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RawEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RawEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RawEvent entities.
func (m *RawEventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RawEventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RawEventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RawEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RawEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RawEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RawEvent entity.
// If the RawEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RawEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RawEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RawEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RawEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RawEvent entity.
// If the RawEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RawEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RawEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventType sets the "event_type" field.
func (m *RawEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *RawEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the RawEvent entity.
// If the RawEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RawEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *RawEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *RawEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *RawEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the RawEvent entity.
// If the RawEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RawEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *RawEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetPayload sets the "payload" field.
func (m *RawEventMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *RawEventMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the RawEvent entity.
// If the RawEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RawEventMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *RawEventMutation) ResetPayload() {
	m.payload = nil
}

// SetProcessed sets the "processed" field.
func (m *RawEventMutation) SetProcessed(b bool) {
	m.processed = &b
}

// Processed returns the value of the "processed" field in the mutation.
func (m *RawEventMutation) Processed() (r bool, exists bool) {
	v := m.processed
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessed returns the old "processed" field's value of the RawEvent entity.
// If the RawEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RawEventMutation) OldProcessed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessed: %w", err)
	}
	return oldValue.Processed, nil
}

// ResetProcessed resets all changes to the "processed" field.
func (m *RawEventMutation) ResetProcessed() {
	m.processed = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *RawEventMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *RawEventMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the RawEvent entity.
// If the RawEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RawEventMutation) OldProcessedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *RawEventMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[rawevent.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *RawEventMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[rawevent.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *RawEventMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, rawevent.FieldProcessedAt)
}

// SetSessionID sets the "session" edge to the Session entity by id.
func (m *RawEventMutation) SetSessionID(id uuid.UUID) {
	m.session = &id
}

// ClearSession clears the "session" edge to the Session entity.
func (m *RawEventMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *RawEventMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *RawEventMutation) SessionID() (id uuid.UUID, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *RawEventMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *RawEventMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the RawEventMutation builder.
func (m *RawEventMutation) Where(ps ...predicate.RawEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RawEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RawEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RawEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RawEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RawEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RawEvent).
func (m *RawEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RawEventMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, rawevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rawevent.FieldUpdatedAt)
	}
	if m.event_type != nil {
		fields = append(fields, rawevent.FieldEventType)
	}
	if m.timestamp != nil {
		fields = append(fields, rawevent.FieldTimestamp)
	}
	if m.payload != nil {
		fields = append(fields, rawevent.FieldPayload)
	}
	if m.processed != nil {
		fields = append(fields, rawevent.FieldProcessed)
	}
	if m.processed_at != nil {
		fields = append(fields, rawevent.FieldProcessedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RawEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rawevent.FieldCreatedAt:
		return m.CreatedAt()
	case rawevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case rawevent.FieldEventType:
		return m.EventType()
	case rawevent.FieldTimestamp:
		return m.Timestamp()
	case rawevent.FieldPayload:
		return m.Payload()
	case rawevent.FieldProcessed:
		return m.Processed()
	case rawevent.FieldProcessedAt:
		return m.ProcessedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RawEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rawevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rawevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rawevent.FieldEventType:
		return m.OldEventType(ctx)
	case rawevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case rawevent.FieldPayload:
		return m.OldPayload(ctx)
	case rawevent.FieldProcessed:
		return m.OldProcessed(ctx)
	case rawevent.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RawEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RawEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rawevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rawevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rawevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case rawevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case rawevent.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case rawevent.FieldProcessed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessed(v)
		return nil
	case rawevent.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RawEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RawEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RawEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RawEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RawEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RawEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rawevent.FieldProcessedAt) {
		fields = append(fields, rawevent.FieldProcessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RawEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RawEventMutation) ClearField(name string) error {
	switch name {
	case rawevent.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown RawEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RawEventMutation) ResetField(name string) error {
	switch name {
	case rawevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rawevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rawevent.FieldEventType:
		m.ResetEventType()
		return nil
	case rawevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case rawevent.FieldPayload:
		m.ResetPayload()
		return nil
	case rawevent.FieldProcessed:
		m.ResetProcessed()
		return nil
	case rawevent.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown RawEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RawEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, rawevent.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RawEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rawevent.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RawEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RawEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RawEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, rawevent.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RawEventMutation) EdgeCleared(name string) bool {
	switch name {
	case rawevent.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RawEventMutation) ClearEdge(name string) error {
	switch name {
	case rawevent.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown RawEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RawEventMutation) ResetEdge(name string) error {
	switch name {
	case rawevent.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown RawEvent edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	status             *session.Status
	deleted_at         *time.Time
	title              *string
	description        *string
	session_status     *session.SessionStatus
	started_at         *time.Time
	ended_at           *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	page_visits        map[uuid.UUID]struct{}
	removedpage_visits map[uuid.UUID]struct{}
	clearedpage_visits bool
	highlights         map[uuid.UUID]struct{}
	removedhighlights  map[uuid.UUID]struct{}
	clearedhighlights  bool
	raw_events         map[uuid.UUID]struct{}
	removedraw_events  map[uuid.UUID]struct{}
	clearedraw_events  bool
	mindmap            *uuid.UUID
	clearedmindmap     bool
	done               bool
	oldValue           func(context.Context) (*Session, error)
	predicates         []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *SessionMutation) SetStatus(s session.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SessionMutation) Status() (r session.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldStatus(ctx context.Context) (v session.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SessionMutation) ResetStatus() {
	m.status = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[session.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, session.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *SessionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SessionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *SessionMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[session.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *SessionMutation) TitleCleared() bool {
	_, ok := m.clearedFields[session.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *SessionMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, session.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *SessionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SessionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SessionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[session.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SessionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[session.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SessionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, session.FieldDescription)
}

// SetSessionStatus sets the "session_status" field.
func (m *SessionMutation) SetSessionStatus(ss session.SessionStatus) {
	m.session_status = &ss
}

// SessionStatus returns the value of the "session_status" field in the mutation.
func (m *SessionMutation) SessionStatus() (r session.SessionStatus, exists bool) {
	v := m.session_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionStatus returns the old "session_status" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldSessionStatus(ctx context.Context) (v session.SessionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionStatus: %w", err)
	}
	return oldValue.SessionStatus, nil
}

// ResetSessionStatus resets all changes to the "session_status" field.
func (m *SessionMutation) ResetSessionStatus() {
	m.session_status = nil
}

// SetStartedAt sets the "started_at" field.
func (m *SessionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SessionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SessionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *SessionMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *SessionMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *SessionMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[session.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *SessionMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *SessionMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, session.FieldEndedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SessionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SessionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddPageVisitIDs adds the "page_visits" edge to the PageVisit entity by ids.
func (m *SessionMutation) AddPageVisitIDs(ids ...uuid.UUID) {
	if m.page_visits == nil {
		m.page_visits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.page_visits[ids[i]] = struct{}{}
	}
}

// ClearPageVisits clears the "page_visits" edge to the PageVisit entity.
func (m *SessionMutation) ClearPageVisits() {
	m.clearedpage_visits = true
}

// PageVisitsCleared reports if the "page_visits" edge to the PageVisit entity was cleared.
func (m *SessionMutation) PageVisitsCleared() bool {
	return m.clearedpage_visits
}

// RemovePageVisitIDs removes the "page_visits" edge to the PageVisit entity by IDs.
func (m *SessionMutation) RemovePageVisitIDs(ids ...uuid.UUID) {
	if m.removedpage_visits == nil {
		m.removedpage_visits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.page_visits, ids[i])
		m.removedpage_visits[ids[i]] = struct{}{}
	}
}

// RemovedPageVisits returns the removed IDs of the "page_visits" edge to the PageVisit entity.
func (m *SessionMutation) RemovedPageVisitsIDs() (ids []uuid.UUID) {
	for id := range m.removedpage_visits {
		ids = append(ids, id)
	}
	return
}

// PageVisitsIDs returns the "page_visits" edge IDs in the mutation.
func (m *SessionMutation) PageVisitsIDs() (ids []uuid.UUID) {
	for id := range m.page_visits {
		ids = append(ids, id)
	}
	return
}

// ResetPageVisits resets all changes to the "page_visits" edge.
func (m *SessionMutation) ResetPageVisits() {
	m.page_visits = nil
	m.clearedpage_visits = false
	m.removedpage_visits = nil
}

// AddHighlightIDs adds the "highlights" edge to the Highlight entity by ids.
func (m *SessionMutation) AddHighlightIDs(ids ...uuid.UUID) {
	if m.highlights == nil {
		m.highlights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.highlights[ids[i]] = struct{}{}
	}
}

// ClearHighlights clears the "highlights" edge to the Highlight entity.
func (m *SessionMutation) ClearHighlights() {
	m.clearedhighlights = true
}

// HighlightsCleared reports if the "highlights" edge to the Highlight entity was cleared.
func (m *SessionMutation) HighlightsCleared() bool {
	return m.clearedhighlights
}

// RemoveHighlightIDs removes the "highlights" edge to the Highlight entity by IDs.
func (m *SessionMutation) RemoveHighlightIDs(ids ...uuid.UUID) {
	if m.removedhighlights == nil {
		m.removedhighlights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.highlights, ids[i])
		m.removedhighlights[ids[i]] = struct{}{}
	}
}

// RemovedHighlights returns the removed IDs of the "highlights" edge to the Highlight entity.
func (m *SessionMutation) RemovedHighlightsIDs() (ids []uuid.UUID) {
	for id := range m.removedhighlights {
		ids = append(ids, id)
	}
	return
}

// HighlightsIDs returns the "highlights" edge IDs in the mutation.
func (m *SessionMutation) HighlightsIDs() (ids []uuid.UUID) {
	for id := range m.highlights {
		ids = append(ids, id)
	}
	return
}

// ResetHighlights resets all changes to the "highlights" edge.
func (m *SessionMutation) ResetHighlights() {
	m.highlights = nil
	m.clearedhighlights = false
	m.removedhighlights = nil
}

// AddRawEventIDs adds the "raw_events" edge to the RawEvent entity by ids.
func (m *SessionMutation) AddRawEventIDs(ids ...uuid.UUID) {
	if m.raw_events == nil {
		m.raw_events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.raw_events[ids[i]] = struct{}{}
	}
}

// ClearRawEvents clears the "raw_events" edge to the RawEvent entity.
func (m *SessionMutation) ClearRawEvents() {
	m.clearedraw_events = true
}

// RawEventsCleared reports if the "raw_events" edge to the RawEvent entity was cleared.
func (m *SessionMutation) RawEventsCleared() bool {
	return m.clearedraw_events
}

// RemoveRawEventIDs removes the "raw_events" edge to the RawEvent entity by IDs.
func (m *SessionMutation) RemoveRawEventIDs(ids ...uuid.UUID) {
	if m.removedraw_events == nil {
		m.removedraw_events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.raw_events, ids[i])
		m.removedraw_events[ids[i]] = struct{}{}
	}
}

// RemovedRawEvents returns the removed IDs of the "raw_events" edge to the RawEvent entity.
func (m *SessionMutation) RemovedRawEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedraw_events {
		ids = append(ids, id)
	}
	return
}

// RawEventsIDs returns the "raw_events" edge IDs in the mutation.
func (m *SessionMutation) RawEventsIDs() (ids []uuid.UUID) {
	for id := range m.raw_events {
		ids = append(ids, id)
	}
	return
}

// ResetRawEvents resets all changes to the "raw_events" edge.
func (m *SessionMutation) ResetRawEvents() {
	m.raw_events = nil
	m.clearedraw_events = false
	m.removedraw_events = nil
}

// SetMindmapID sets the "mindmap" edge to the MindmapGraph entity by id.
func (m *SessionMutation) SetMindmapID(id uuid.UUID) {
	m.mindmap = &id
}

// ClearMindmap clears the "mindmap" edge to the MindmapGraph entity.
func (m *SessionMutation) ClearMindmap() {
	m.clearedmindmap = true
}

// MindmapCleared reports if the "mindmap" edge to the MindmapGraph entity was cleared.
func (m *SessionMutation) MindmapCleared() bool {
	return m.clearedmindmap
}

// MindmapID returns the "mindmap" edge ID in the mutation.
func (m *SessionMutation) MindmapID() (id uuid.UUID, exists bool) {
	if m.mindmap != nil {
		return *m.mindmap, true
	}
	return
}

// MindmapIDs returns the "mindmap" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MindmapID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) MindmapIDs() (ids []uuid.UUID) {
	if id := m.mindmap; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMindmap resets all changes to the "mindmap" edge.
func (m *SessionMutation) ResetMindmap() {
	m.mindmap = nil
	m.clearedmindmap = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, session.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, session.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, session.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, session.FieldDescription)
	}
	if m.session_status != nil {
		fields = append(fields, session.FieldSessionStatus)
	}
	if m.started_at != nil {
		fields = append(fields, session.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, session.FieldEndedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldStatus:
		return m.Status()
	case session.FieldDeletedAt:
		return m.DeletedAt()
	case session.FieldTitle:
		return m.Title()
	case session.FieldDescription:
		return m.Description()
	case session.FieldSessionStatus:
		return m.SessionStatus()
	case session.FieldStartedAt:
		return m.StartedAt()
	case session.FieldEndedAt:
		return m.EndedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldStatus:
		return m.OldStatus(ctx)
	case session.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case session.FieldTitle:
		return m.OldTitle(ctx)
	case session.FieldDescription:
		return m.OldDescription(ctx)
	case session.FieldSessionStatus:
		return m.OldSessionStatus(ctx)
	case session.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case session.FieldEndedAt:
		return m.OldEndedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldStatus:
		v, ok := value.(session.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case session.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case session.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case session.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case session.FieldSessionStatus:
		v, ok := value.(session.SessionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionStatus(v)
		return nil
	case session.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case session.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldDeletedAt) {
		fields = append(fields, session.FieldDeletedAt)
	}
	if m.FieldCleared(session.FieldTitle) {
		fields = append(fields, session.FieldTitle)
	}
	if m.FieldCleared(session.FieldDescription) {
		fields = append(fields, session.FieldDescription)
	}
	if m.FieldCleared(session.FieldEndedAt) {
		fields = append(fields, session.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case session.FieldTitle:
		m.ClearTitle()
		return nil
	case session.FieldDescription:
		m.ClearDescription()
		return nil
	case session.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldStatus:
		m.ResetStatus()
		return nil
	case session.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case session.FieldTitle:
		m.ResetTitle()
		return nil
	case session.FieldDescription:
		m.ResetDescription()
		return nil
	case session.FieldSessionStatus:
		m.ResetSessionStatus()
		return nil
	case session.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case session.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	if m.page_visits != nil {
		edges = append(edges, session.EdgePageVisits)
	}
	if m.highlights != nil {
		edges = append(edges, session.EdgeHighlights)
	}
	if m.raw_events != nil {
		edges = append(edges, session.EdgeRawEvents)
	}
	if m.mindmap != nil {
		edges = append(edges, session.EdgeMindmap)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgePageVisits:
		ids := make([]ent.Value, 0, len(m.page_visits))
		for id := range m.page_visits {
			ids = append(ids, id)
		}
		return ids
	case session.EdgeHighlights:
		ids := make([]ent.Value, 0, len(m.highlights))
		for id := range m.highlights {
			ids = append(ids, id)
		}
		return ids
	case session.EdgeRawEvents:
		ids := make([]ent.Value, 0, len(m.raw_events))
		for id := range m.raw_events {
			ids = append(ids, id)
		}
		return ids
	case session.EdgeMindmap:
		if id := m.mindmap; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpage_visits != nil {
		edges = append(edges, session.EdgePageVisits)
	}
	if m.removedhighlights != nil {
		edges = append(edges, session.EdgeHighlights)
	}
	if m.removedraw_events != nil {
		edges = append(edges, session.EdgeRawEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case session.EdgePageVisits:
		ids := make([]ent.Value, 0, len(m.removedpage_visits))
		for id := range m.removedpage_visits {
			ids = append(ids, id)
		}
		return ids
	case session.EdgeHighlights:
		ids := make([]ent.Value, 0, len(m.removedhighlights))
		for id := range m.removedhighlights {
			ids = append(ids, id)
		}
		return ids
	case session.EdgeRawEvents:
		ids := make([]ent.Value, 0, len(m.removedraw_events))
		for id := range m.removedraw_events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	if m.clearedpage_visits {
		edges = append(edges, session.EdgePageVisits)
	}
	if m.clearedhighlights {
		edges = append(edges, session.EdgeHighlights)
	}
	if m.clearedraw_events {
		edges = append(edges, session.EdgeRawEvents)
	}
	if m.clearedmindmap {
		edges = append(edges, session.EdgeMindmap)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	case session.EdgePageVisits:
		return m.clearedpage_visits
	case session.EdgeHighlights:
		return m.clearedhighlights
	case session.EdgeRawEvents:
		return m.clearedraw_events
	case session.EdgeMindmap:
		return m.clearedmindmap
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	case session.EdgeMindmap:
		m.ClearMindmap()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	case session.EdgePageVisits:
		m.ResetPageVisits()
		return nil
	case session.EdgeHighlights:
		m.ResetHighlights()
		return nil
	case session.EdgeRawEvents:
		m.ResetRawEvents()
		return nil
	case session.EdgeMindmap:
		m.ResetMindmap()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// URLMutation represents an operation that mutates the URL nodes in the graph.
type URLMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	url                *string
	url_hash           *string
	title              *string
	content            *string
	summary            *string
	keywords           *[]string
	appendkeywords     []string
	crawled_at         *time.Time
	clearedFields      map[string]struct{}
	page_visits        map[uuid.UUID]struct{}
	removedpage_visits map[uuid.UUID]struct{}
	clearedpage_visits bool
	done               bool
	oldValue           func(context.Context) (*URL, error)
	predicates         []predicate.URL
}

var _ ent.Mutation = (*URLMutation)(nil)

// urlOption allows management of the mutation configuration using functional options.
type urlOption func(*URLMutation)

// newURLMutation creates new mutation for the URL entity.
func newURLMutation(c config, op Op, opts ...urlOption) *URLMutation {
	m := &URLMutation{
		config:        c,
		op:            op,
		typ:           TypeURL,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withURLID sets the ID field of the mutation.
func withURLID(id uuid.UUID) urlOption {
	return func(m *URLMutation) {
		var (
			err   error
			once  sync.Once
			value *URL
		)
		m.oldValue = func(ctx context.Context) (*URL, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().URL.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withURL sets the old URL of the mutation.
func withURL(node *URL) urlOption {
	return func(m *URLMutation) {
		m.oldValue = func(context.Context) (*URL, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m URLMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m URLMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of URL entities.
func (m *URLMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *URLMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *URLMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().URL.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *URLMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *URLMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *URLMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *URLMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *URLMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *URLMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetURL sets the "url" field.
func (m *URLMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *URLMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *URLMutation) ResetURL() {
	m.url = nil
}

// SetURLHash sets the "url_hash" field.
func (m *URLMutation) SetURLHash(s string) {
	m.url_hash = &s
}

// URLHash returns the value of the "url_hash" field in the mutation.
func (m *URLMutation) URLHash() (r string, exists bool) {
	v := m.url_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldURLHash returns the old "url_hash" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldURLHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLHash: %w", err)
	}
	return oldValue.URLHash, nil
}

// ResetURLHash resets all changes to the "url_hash" field.
func (m *URLMutation) ResetURLHash() {
	m.url_hash = nil
}

// SetTitle sets the "title" field.
func (m *URLMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *URLMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *URLMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[url.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *URLMutation) TitleCleared() bool {
	_, ok := m.clearedFields[url.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *URLMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, url.FieldTitle)
}

// SetContent sets the "content" field.
func (m *URLMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *URLMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *URLMutation) ClearContent() {
	m.content = nil
	m.clearedFields[url.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *URLMutation) ContentCleared() bool {
	_, ok := m.clearedFields[url.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *URLMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, url.FieldContent)
}

// SetSummary sets the "summary" field.
func (m *URLMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *URLMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *URLMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[url.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *URLMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[url.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *URLMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, url.FieldSummary)
}

// SetKeywords sets the "keywords" field.
func (m *URLMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *URLMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *URLMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *URLMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ClearKeywords clears the value of the "keywords" field.
func (m *URLMutation) ClearKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	m.clearedFields[url.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *URLMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[url.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *URLMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	delete(m.clearedFields, url.FieldKeywords)
}

// SetCrawledAt sets the "crawled_at" field.
func (m *URLMutation) SetCrawledAt(t time.Time) {
	m.crawled_at = &t
}

// CrawledAt returns the value of the "crawled_at" field in the mutation.
func (m *URLMutation) CrawledAt() (r time.Time, exists bool) {
	v := m.crawled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCrawledAt returns the old "crawled_at" field's value of the URL entity.
// If the URL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *URLMutation) OldCrawledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrawledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrawledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrawledAt: %w", err)
	}
	return oldValue.CrawledAt, nil
}

// ClearCrawledAt clears the value of the "crawled_at" field.
func (m *URLMutation) ClearCrawledAt() {
	m.crawled_at = nil
	m.clearedFields[url.FieldCrawledAt] = struct{}{}
}

// CrawledAtCleared returns if the "crawled_at" field was cleared in this mutation.
func (m *URLMutation) CrawledAtCleared() bool {
	_, ok := m.clearedFields[url.FieldCrawledAt]
	return ok
}

// ResetCrawledAt resets all changes to the "crawled_at" field.
func (m *URLMutation) ResetCrawledAt() {
	m.crawled_at = nil
	delete(m.clearedFields, url.FieldCrawledAt)
}

// AddPageVisitIDs adds the "page_visits" edge to the PageVisit entity by ids.
func (m *URLMutation) AddPageVisitIDs(ids ...uuid.UUID) {
	if m.page_visits == nil {
		m.page_visits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.page_visits[ids[i]] = struct{}{}
	}
}

// ClearPageVisits clears the "page_visits" edge to the PageVisit entity.
func (m *URLMutation) ClearPageVisits() {
	m.clearedpage_visits = true
}

// PageVisitsCleared reports if the "page_visits" edge to the PageVisit entity was cleared.
func (m *URLMutation) PageVisitsCleared() bool {
	return m.clearedpage_visits
}

// RemovePageVisitIDs removes the "page_visits" edge to the PageVisit entity by IDs.
func (m *URLMutation) RemovePageVisitIDs(ids ...uuid.UUID) {
	if m.removedpage_visits == nil {
		m.removedpage_visits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.page_visits, ids[i])
		m.removedpage_visits[ids[i]] = struct{}{}
	}
}

// RemovedPageVisits returns the removed IDs of the "page_visits" edge to the PageVisit entity.
func (m *URLMutation) RemovedPageVisitsIDs() (ids []uuid.UUID) {
	for id := range m.removedpage_visits {
		ids = append(ids, id)
	}
	return
}

// PageVisitsIDs returns the "page_visits" edge IDs in the mutation.
func (m *URLMutation) PageVisitsIDs() (ids []uuid.UUID) {
	for id := range m.page_visits {
		ids = append(ids, id)
	}
	return
}

// ResetPageVisits resets all changes to the "page_visits" edge.
func (m *URLMutation) ResetPageVisits() {
	m.page_visits = nil
	m.clearedpage_visits = false
	m.removedpage_visits = nil
}

// Where appends a list predicates to the URLMutation builder.
func (m *URLMutation) Where(ps ...predicate.URL) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the URLMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *URLMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.URL, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *URLMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *URLMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (URL).
func (m *URLMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *URLMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, url.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, url.FieldUpdatedAt)
	}
	if m.url != nil {
		fields = append(fields, url.FieldURL)
	}
	if m.url_hash != nil {
		fields = append(fields, url.FieldURLHash)
	}
	if m.title != nil {
		fields = append(fields, url.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, url.FieldContent)
	}
	if m.summary != nil {
		fields = append(fields, url.FieldSummary)
	}
	if m.keywords != nil {
		fields = append(fields, url.FieldKeywords)
	}
	if m.crawled_at != nil {
		fields = append(fields, url.FieldCrawledAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *URLMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case url.FieldCreatedAt:
		return m.CreatedAt()
	case url.FieldUpdatedAt:
		return m.UpdatedAt()
	case url.FieldURL:
		return m.URL()
	case url.FieldURLHash:
		return m.URLHash()
	case url.FieldTitle:
		return m.Title()
	case url.FieldContent:
		return m.Content()
	case url.FieldSummary:
		return m.Summary()
	case url.FieldKeywords:
		return m.Keywords()
	case url.FieldCrawledAt:
		return m.CrawledAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *URLMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case url.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case url.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case url.FieldURL:
		return m.OldURL(ctx)
	case url.FieldURLHash:
		return m.OldURLHash(ctx)
	case url.FieldTitle:
		return m.OldTitle(ctx)
	case url.FieldContent:
		return m.OldContent(ctx)
	case url.FieldSummary:
		return m.OldSummary(ctx)
	case url.FieldKeywords:
		return m.OldKeywords(ctx)
	case url.FieldCrawledAt:
		return m.OldCrawledAt(ctx)
	}
	return nil, fmt.Errorf("unknown URL field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLMutation) SetField(name string, value ent.Value) error {
	switch name {
	case url.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case url.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case url.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case url.FieldURLHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLHash(v)
		return nil
	case url.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case url.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case url.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case url.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case url.FieldCrawledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrawledAt(v)
		return nil
	}
	return fmt.Errorf("unknown URL field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *URLMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *URLMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *URLMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown URL numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *URLMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(url.FieldTitle) {
		fields = append(fields, url.FieldTitle)
	}
	if m.FieldCleared(url.FieldContent) {
		fields = append(fields, url.FieldContent)
	}
	if m.FieldCleared(url.FieldSummary) {
		fields = append(fields, url.FieldSummary)
	}
	if m.FieldCleared(url.FieldKeywords) {
		fields = append(fields, url.FieldKeywords)
	}
	if m.FieldCleared(url.FieldCrawledAt) {
		fields = append(fields, url.FieldCrawledAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *URLMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *URLMutation) ClearField(name string) error {
	switch name {
	case url.FieldTitle:
		m.ClearTitle()
		return nil
	case url.FieldContent:
		m.ClearContent()
		return nil
	case url.FieldSummary:
		m.ClearSummary()
		return nil
	case url.FieldKeywords:
		m.ClearKeywords()
		return nil
	case url.FieldCrawledAt:
		m.ClearCrawledAt()
		return nil
	}
	return fmt.Errorf("unknown URL nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *URLMutation) ResetField(name string) error {
	switch name {
	case url.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case url.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case url.FieldURL:
		m.ResetURL()
		return nil
	case url.FieldURLHash:
		m.ResetURLHash()
		return nil
	case url.FieldTitle:
		m.ResetTitle()
		return nil
	case url.FieldContent:
		m.ResetContent()
		return nil
	case url.FieldSummary:
		m.ResetSummary()
		return nil
	case url.FieldKeywords:
		m.ResetKeywords()
		return nil
	case url.FieldCrawledAt:
		m.ResetCrawledAt()
		return nil
	}
	return fmt.Errorf("unknown URL field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *URLMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.page_visits != nil {
		edges = append(edges, url.EdgePageVisits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *URLMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case url.EdgePageVisits:
		ids := make([]ent.Value, 0, len(m.page_visits))
		for id := range m.page_visits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *URLMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpage_visits != nil {
		edges = append(edges, url.EdgePageVisits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *URLMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case url.EdgePageVisits:
		ids := make([]ent.Value, 0, len(m.removedpage_visits))
		for id := range m.removedpage_visits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *URLMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpage_visits {
		edges = append(edges, url.EdgePageVisits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *URLMutation) EdgeCleared(name string) bool {
	switch name {
	case url.EdgePageVisits:
		return m.clearedpage_visits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *URLMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown URL unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *URLMutation) ResetEdge(name string) error {
	switch name {
	case url.EdgePageVisits:
		m.ResetPageVisits()
		return nil
	}
	return fmt.Errorf("unknown URL edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	status                       *user.Status
	deleted_at                   *time.Time
	email                        *string
	password_hash                *string
	clearedFields                map[string]struct{}
	settings                     *uuid.UUID
	clearedsettings              bool
	sessions                     map[uuid.UUID]struct{}
	removedsessions              map[uuid.UUID]struct{}
	clearedsessions              bool
	password_reset_tokens        map[uuid.UUID]struct{}
	removedpassword_reset_tokens map[uuid.UUID]struct{}
	clearedpassword_reset_tokens bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetSettingsID sets the "settings" edge to the UserSettings entity by id.
func (m *UserMutation) SetSettingsID(id uuid.UUID) {
	m.settings = &id
}

// ClearSettings clears the "settings" edge to the UserSettings entity.
func (m *UserMutation) ClearSettings() {
	m.clearedsettings = true
}

// SettingsCleared reports if the "settings" edge to the UserSettings entity was cleared.
func (m *UserMutation) SettingsCleared() bool {
	return m.clearedsettings
}

// SettingsID returns the "settings" edge ID in the mutation.
func (m *UserMutation) SettingsID() (id uuid.UUID, exists bool) {
	if m.settings != nil {
		return *m.settings, true
	}
	return
}

// SettingsIDs returns the "settings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SettingsIDs() (ids []uuid.UUID) {
	if id := m.settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettings resets all changes to the "settings" edge.
func (m *UserMutation) ResetSettings() {
	m.settings = nil
	m.clearedsettings = false
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddPasswordResetTokenIDs adds the "password_reset_tokens" edge to the PasswordResetToken entity by ids.
func (m *UserMutation) AddPasswordResetTokenIDs(ids ...uuid.UUID) {
	if m.password_reset_tokens == nil {
		m.password_reset_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.password_reset_tokens[ids[i]] = struct{}{}
	}
}

// ClearPasswordResetTokens clears the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) ClearPasswordResetTokens() {
	m.clearedpassword_reset_tokens = true
}

// PasswordResetTokensCleared reports if the "password_reset_tokens" edge to the PasswordResetToken entity was cleared.
func (m *UserMutation) PasswordResetTokensCleared() bool {
	return m.clearedpassword_reset_tokens
}

// RemovePasswordResetTokenIDs removes the "password_reset_tokens" edge to the PasswordResetToken entity by IDs.
func (m *UserMutation) RemovePasswordResetTokenIDs(ids ...uuid.UUID) {
	if m.removedpassword_reset_tokens == nil {
		m.removedpassword_reset_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.password_reset_tokens, ids[i])
		m.removedpassword_reset_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPasswordResetTokens returns the removed IDs of the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) RemovedPasswordResetTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedpassword_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// PasswordResetTokensIDs returns the "password_reset_tokens" edge IDs in the mutation.
func (m *UserMutation) PasswordResetTokensIDs() (ids []uuid.UUID) {
	for id := range m.password_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPasswordResetTokens resets all changes to the "password_reset_tokens" edge.
func (m *UserMutation) ResetPasswordResetTokens() {
	m.password_reset_tokens = nil
	m.clearedpassword_reset_tokens = false
	m.removedpassword_reset_tokens = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.settings != nil {
		edges = append(edges, user.EdgeSettings)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.password_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSettings:
		if id := m.settings; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.password_reset_tokens))
		for id := range m.password_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedpassword_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.removedpassword_reset_tokens))
		for id := range m.removedpassword_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsettings {
		edges = append(edges, user.EdgeSettings)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedpassword_reset_tokens {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSettings:
		return m.clearedsettings
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgePasswordResetTokens:
		return m.clearedpassword_reset_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSettings:
		m.ResetSettings()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgePasswordResetTokens:
		m.ResetPasswordResetTokens()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserSettingsMutation represents an operation that mutates the UserSettings nodes in the graph.
type UserSettingsMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	theme                      *usersettings.Theme
	email_notifications        *bool
	browser_notifications      *bool
	language                   *string
	session_timeout_minutes    *int
	addsession_timeout_minutes *int
	auto_summarize             *bool
	extension_settings         *map[string]interface{}
	clearedFields              map[string]struct{}
	user                       *uuid.UUID
	cleareduser                bool
	done                       bool
	oldValue                   func(context.Context) (*UserSettings, error)
	predicates                 []predicate.UserSettings
}

var _ ent.Mutation = (*UserSettingsMutation)(nil)

// usersettingsOption allows management of the mutation configuration using functional options.
type usersettingsOption func(*UserSettingsMutation)

// newUserSettingsMutation creates new mutation for the UserSettings entity.
func newUserSettingsMutation(c config, op Op, opts ...usersettingsOption) *UserSettingsMutation {
	m := &UserSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSettingsID sets the ID field of the mutation.
func withUserSettingsID(id uuid.UUID) usersettingsOption {
	return func(m *UserSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSettings
		)
		m.oldValue = func(ctx context.Context) (*UserSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSettings sets the old UserSettings of the mutation.
func withUserSettings(node *UserSettings) usersettingsOption {
	return func(m *UserSettingsMutation) {
		m.oldValue = func(context.Context) (*UserSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSettings entities.
func (m *UserSettingsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSettingsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSettingsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTheme sets the "theme" field.
func (m *UserSettingsMutation) SetTheme(u usersettings.Theme) {
	m.theme = &u
}

// Theme returns the value of the "theme" field in the mutation.
func (m *UserSettingsMutation) Theme() (r usersettings.Theme, exists bool) {
	v := m.theme
	if v == nil {
		return
	}
	return *v, true
}

// OldTheme returns the old "theme" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldTheme(ctx context.Context) (v usersettings.Theme, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTheme: %w", err)
	}
	return oldValue.Theme, nil
}

// ResetTheme resets all changes to the "theme" field.
func (m *UserSettingsMutation) ResetTheme() {
	m.theme = nil
}

// SetEmailNotifications sets the "email_notifications" field.
func (m *UserSettingsMutation) SetEmailNotifications(b bool) {
	m.email_notifications = &b
}

// EmailNotifications returns the value of the "email_notifications" field in the mutation.
func (m *UserSettingsMutation) EmailNotifications() (r bool, exists bool) {
	v := m.email_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailNotifications returns the old "email_notifications" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldEmailNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailNotifications: %w", err)
	}
	return oldValue.EmailNotifications, nil
}

// ResetEmailNotifications resets all changes to the "email_notifications" field.
func (m *UserSettingsMutation) ResetEmailNotifications() {
	m.email_notifications = nil
}

// SetBrowserNotifications sets the "browser_notifications" field.
func (m *UserSettingsMutation) SetBrowserNotifications(b bool) {
	m.browser_notifications = &b
}

// BrowserNotifications returns the value of the "browser_notifications" field in the mutation.
func (m *UserSettingsMutation) BrowserNotifications() (r bool, exists bool) {
	v := m.browser_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowserNotifications returns the old "browser_notifications" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldBrowserNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowserNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowserNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowserNotifications: %w", err)
	}
	return oldValue.BrowserNotifications, nil
}

// ResetBrowserNotifications resets all changes to the "browser_notifications" field.
func (m *UserSettingsMutation) ResetBrowserNotifications() {
	m.browser_notifications = nil
}

// SetLanguage sets the "language" field.
func (m *UserSettingsMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *UserSettingsMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *UserSettingsMutation) ResetLanguage() {
	m.language = nil
}

// SetSessionTimeoutMinutes sets the "session_timeout_minutes" field.
func (m *UserSettingsMutation) SetSessionTimeoutMinutes(i int) {
	m.session_timeout_minutes = &i
	m.addsession_timeout_minutes = nil
}

// SessionTimeoutMinutes returns the value of the "session_timeout_minutes" field in the mutation.
func (m *UserSettingsMutation) SessionTimeoutMinutes() (r int, exists bool) {
	v := m.session_timeout_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionTimeoutMinutes returns the old "session_timeout_minutes" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldSessionTimeoutMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionTimeoutMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionTimeoutMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionTimeoutMinutes: %w", err)
	}
	return oldValue.SessionTimeoutMinutes, nil
}

// AddSessionTimeoutMinutes adds i to the "session_timeout_minutes" field.
func (m *UserSettingsMutation) AddSessionTimeoutMinutes(i int) {
	if m.addsession_timeout_minutes != nil {
		*m.addsession_timeout_minutes += i
	} else {
		m.addsession_timeout_minutes = &i
	}
}

// AddedSessionTimeoutMinutes returns the value that was added to the "session_timeout_minutes" field in this mutation.
func (m *UserSettingsMutation) AddedSessionTimeoutMinutes() (r int, exists bool) {
	v := m.addsession_timeout_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSessionTimeoutMinutes resets all changes to the "session_timeout_minutes" field.
func (m *UserSettingsMutation) ResetSessionTimeoutMinutes() {
	m.session_timeout_minutes = nil
	m.addsession_timeout_minutes = nil
}

// SetAutoSummarize sets the "auto_summarize" field.
func (m *UserSettingsMutation) SetAutoSummarize(b bool) {
	m.auto_summarize = &b
}

// AutoSummarize returns the value of the "auto_summarize" field in the mutation.
func (m *UserSettingsMutation) AutoSummarize() (r bool, exists bool) {
	v := m.auto_summarize
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoSummarize returns the old "auto_summarize" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldAutoSummarize(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoSummarize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoSummarize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoSummarize: %w", err)
	}
	return oldValue.AutoSummarize, nil
}

// ResetAutoSummarize resets all changes to the "auto_summarize" field.
func (m *UserSettingsMutation) ResetAutoSummarize() {
	m.auto_summarize = nil
}

// SetExtensionSettings sets the "extension_settings" field.
func (m *UserSettingsMutation) SetExtensionSettings(value map[string]interface{}) {
	m.extension_settings = &value
}

// ExtensionSettings returns the value of the "extension_settings" field in the mutation.
func (m *UserSettingsMutation) ExtensionSettings() (r map[string]interface{}, exists bool) {
	v := m.extension_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensionSettings returns the old "extension_settings" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldExtensionSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensionSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensionSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensionSettings: %w", err)
	}
	return oldValue.ExtensionSettings, nil
}

// ClearExtensionSettings clears the value of the "extension_settings" field.
func (m *UserSettingsMutation) ClearExtensionSettings() {
	m.extension_settings = nil
	m.clearedFields[usersettings.FieldExtensionSettings] = struct{}{}
}

// ExtensionSettingsCleared returns if the "extension_settings" field was cleared in this mutation.
func (m *UserSettingsMutation) ExtensionSettingsCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldExtensionSettings]
	return ok
}

// ResetExtensionSettings resets all changes to the "extension_settings" field.
func (m *UserSettingsMutation) ResetExtensionSettings() {
	m.extension_settings = nil
	delete(m.clearedFields, usersettings.FieldExtensionSettings)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserSettingsMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSettingsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSettingsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserSettingsMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSettingsMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSettingsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserSettingsMutation builder.
func (m *UserSettingsMutation) Where(ps ...predicate.UserSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSettings).
func (m *UserSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSettingsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, usersettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersettings.FieldUpdatedAt)
	}
	if m.theme != nil {
		fields = append(fields, usersettings.FieldTheme)
	}
	if m.email_notifications != nil {
		fields = append(fields, usersettings.FieldEmailNotifications)
	}
	if m.browser_notifications != nil {
		fields = append(fields, usersettings.FieldBrowserNotifications)
	}
	if m.language != nil {
		fields = append(fields, usersettings.FieldLanguage)
	}
	if m.session_timeout_minutes != nil {
		fields = append(fields, usersettings.FieldSessionTimeoutMinutes)
	}
	if m.auto_summarize != nil {
		fields = append(fields, usersettings.FieldAutoSummarize)
	}
	if m.extension_settings != nil {
		fields = append(fields, usersettings.FieldExtensionSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersettings.FieldCreatedAt:
		return m.CreatedAt()
	case usersettings.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersettings.FieldTheme:
		return m.Theme()
	case usersettings.FieldEmailNotifications:
		return m.EmailNotifications()
	case usersettings.FieldBrowserNotifications:
		return m.BrowserNotifications()
	case usersettings.FieldLanguage:
		return m.Language()
	case usersettings.FieldSessionTimeoutMinutes:
		return m.SessionTimeoutMinutes()
	case usersettings.FieldAutoSummarize:
		return m.AutoSummarize()
	case usersettings.FieldExtensionSettings:
		return m.ExtensionSettings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersettings.FieldTheme:
		return m.OldTheme(ctx)
	case usersettings.FieldEmailNotifications:
		return m.OldEmailNotifications(ctx)
	case usersettings.FieldBrowserNotifications:
		return m.OldBrowserNotifications(ctx)
	case usersettings.FieldLanguage:
		return m.OldLanguage(ctx)
	case usersettings.FieldSessionTimeoutMinutes:
		return m.OldSessionTimeoutMinutes(ctx)
	case usersettings.FieldAutoSummarize:
		return m.OldAutoSummarize(ctx)
	case usersettings.FieldExtensionSettings:
		return m.OldExtensionSettings(ctx)
	}
	return nil, fmt.Errorf("unknown UserSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersettings.FieldTheme:
		v, ok := value.(usersettings.Theme)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTheme(v)
		return nil
	case usersettings.FieldEmailNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailNotifications(v)
		return nil
	case usersettings.FieldBrowserNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowserNotifications(v)
		return nil
	case usersettings.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case usersettings.FieldSessionTimeoutMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionTimeoutMinutes(v)
		return nil
	case usersettings.FieldAutoSummarize:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoSummarize(v)
		return nil
	case usersettings.FieldExtensionSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensionSettings(v)
		return nil
	}
	return fmt.Errorf("unknown UserSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSettingsMutation) AddedFields() []string {
	var fields []string
	if m.addsession_timeout_minutes != nil {
		fields = append(fields, usersettings.FieldSessionTimeoutMinutes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usersettings.FieldSessionTimeoutMinutes:
		return m.AddedSessionTimeoutMinutes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usersettings.FieldSessionTimeoutMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionTimeoutMinutes(v)
		return nil
	}
	return fmt.Errorf("unknown UserSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersettings.FieldExtensionSettings) {
		fields = append(fields, usersettings.FieldExtensionSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSettingsMutation) ClearField(name string) error {
	switch name {
	case usersettings.FieldExtensionSettings:
		m.ClearExtensionSettings()
		return nil
	}
	return fmt.Errorf("unknown UserSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSettingsMutation) ResetField(name string) error {
	switch name {
	case usersettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersettings.FieldTheme:
		m.ResetTheme()
		return nil
	case usersettings.FieldEmailNotifications:
		m.ResetEmailNotifications()
		return nil
	case usersettings.FieldBrowserNotifications:
		m.ResetBrowserNotifications()
		return nil
	case usersettings.FieldLanguage:
		m.ResetLanguage()
		return nil
	case usersettings.FieldSessionTimeoutMinutes:
		m.ResetSessionTimeoutMinutes()
		return nil
	case usersettings.FieldAutoSummarize:
		m.ResetAutoSummarize()
		return nil
	case usersettings.FieldExtensionSettings:
		m.ResetExtensionSettings()
		return nil
	}
	return fmt.Errorf("unknown UserSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usersettings.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersettings.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usersettings.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case usersettings.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSettingsMutation) ClearEdge(name string) error {
	switch name {
	case usersettings.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSettingsMutation) ResetEdge(name string) error {
	switch name {
	case usersettings.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSettings edge %s", name)
}
